<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprTaketento</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

healthpointsStart = 2;
healthpoints = healthpointsStart;
contactDamage = 3;

category = "cluster, flying, nature";

blockCollision = 0;
grav = 0;

facePlayerOnSpawn = true;

// Enemy specific code
phase = 1;
chaseWait = 50;
chaseTimer = 0;
rotateChange = 2.5;

spd = 1.15;

imgSpd = 0.2;
imgIndex = 0;
image_speed = 0.2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (entityCanStep())
{
    var megax = 0, megay = 0;
    
    if (instance_exists(target))
    {
        megax = target.x;
        megay = target.y;
    }
    
    switch (phase)
    {
        case 1: // flying casually
        // animation 
            imgIndex += imgSpd;
            if (imgIndex &gt;= 2)
            {
                imgIndex = imgIndex mod 2;
            }
            
            // wait to chase
            if (instance_exists(target))
            {
                chaseTimer += 1;
            }
            if (chaseTimer &gt;= chaseWait)
            {
                phase = 2;
                chaseTimer = 0;
                xspeed = 0;
                yspeed = 0;
                speed = spd;
                direction = 90;
                imgIndex = 2;
                instance_create(x, y - 10, objTakentoPropeller);
            }
            break;
        case 2: // chase megaman
        /* this is kind of confusing, but basically we're seeing if the player is more or less than a certain angle away from where we're
            currently pointing, and if they are, increase/decrease our angle by that distance */
        /* This is a special kind of error handler that prevents chibee from moving completely straight and unable to fly towards the player
            if the player moves directly straight against the direction chibee is flying */ 
            var pxd = megax - x;
            var pyd = megay - y;
            var pangle = 0;
            if (pxd != 0)
            {
                pangle = point_direction(x, y, megax, megay);
            }
            else
            {
                if (pyd &gt;= 0)
                {
                    pangle = 270;
                }
                if (pyd &lt; 0)
                {
                    pangle = 90;
                }
            }
            
            // and now that we have the angle the player is facing, we take the difference of the angles
            var change = direction - pangle;
            
            // loop degree check, so the angle isn't above 360 or below 0
            if (change &gt; 360)
            {
                change -= 360;
            }
            else if (change &lt; 0)
            {
                change += 360;
            }
            
            /* this is interesting. So, by subtracting it by 180 it sort of aligns change to be how far away our angle to megaman is from our own angle
            we're pointing at as if our own angle is centered at 0 */
            change -= 180;
            
            /* and now, we just check how off mega man is, and do stuff accordingly (and also I reuse change to become the distance we change the
            angle )*/
            
            // first though, we're going to animate faster if our angle offset is big enough
            if (!(change &gt; 100 || change &lt; -100))
            {
                imgIndex += imgSpd;
            }
            if (change &gt; rotateChange)
            {
                change = rotateChange;
            }
            if (change &lt; -rotateChange)
            {
                change = -rotateChange;
            }
            direction += change;
            
            // animation
            imgIndex += imgSpd;
            if (imgIndex &gt;= 5)
            {
                imgIndex = 2 + imgIndex mod 5;
            }
            break;
    }
}
else if (dead)
{
    phase = 1;
    direction = 0;
    speed = 0;
    chaseTimer = 0;
    imgIndex = 0;
}

image_index = imgIndex div 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// spawn event
event_inherited();

if (spawned)
{
    xspeed = spd * image_xscale;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
