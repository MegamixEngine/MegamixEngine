<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprDrillun</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>sprDrillunMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// An unused enemy from GB I. Hovers in place when the player is far away; continuously drops to the ground and rises back up when the player is close.
/// The top of the enemy is a solid platform, but the bottom still does damage.
/// Suitable for puzzle-platforming or for surprising players with attacks from above.

event_inherited();

respawn = true;

healthpointsStart = 3;
healthpoints = healthpointsStart;
contactDamage = 5;
contactStart = contactDamage;

isSolid = 2;

grav = 0;

behaviourType = 1;

// Enemy specific code
image_speed = 0;
alarmStop = 0;
imgTimer = 0;
img = 0;
phase = 0;
ys = 0;

//creation code - change the ai of the enemy here.
radius = 48; //how large the detection radius of drillun
attackTimerMax = 21; //how long it waits before rising.
dropSpeed = 2.5; //how fast this drops
retreatSpeed = -0.5; //how fast this retreat to start location.
imgTimerMax = 5; //how many frames till animation image changes

animationLength = 2; //how many frames of animation this sprite uses per cycle
inactiveStart = 0; //the image index of the start of 'inactive' animation
activeStart = 0; //the image index of the start of 'active and falling' animation
retreatStart = 0;//the image index of the start of 'returning to start' animation

childObject = objSlideDust; //if set, these objects are created when hitting ground
twinObjects = true; //if true, creates objects either side, otherwise create one object aimed towards target
childXOffset = 5;//how far away the child object is created
childSprite = noone; //if set, set the sprite of object when hitting ground

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ys = yspeed;

event_inherited();

if (entityCanStep())
{
    imgTimer ++;
    if (imgTimer &gt;= imgTimerMax)
    {
        img ++;
        if (img &gt;= animationLength)
        {
            img = 0;
        }
        imgTimer = 0;
    }
    switch (phase)
    {
        case 0: default: image_index = inactiveStart + img; break;
        case 1: image_index = activeStart + img; break;
        case 2: image_index = retreatStart + img; break;
    }

    if (instance_exists(target))
    {
        if (abs(target.x - x) &lt; radius)
        {
            if (abs(y-ystart) &lt; 1)
            {
                yspeed = dropSpeed;
                phase = 1;
            }
        }
    }
    
    if (alarmStop)
    {
        alarmStop += 1;
        if (alarmStop == attackTimerMax)
        {
            yspeed = retreatSpeed;
            alarmStop = 0;
            phase = 2;
        }
    }
    
    if (yspeed == 0)
    {
        if (ys &gt; 0)
        {
            alarmStop = 1;
            if (childObject != noone)
            {
                if (twinObjects)
                {
                    repeat (2)
                    {
                        image_xscale *= -1;
                        var i = instance_create(x + childXOffset * image_xscale, bbox_bottom - 1, childObject);
                        if (childSprite != noone)
                            i.sprite_index = childSprite;
                        i.image_xscale = -image_xscale;
                    }
                }
                else
                {
                    var storeXS = image_xscale;
                    calibrateDirection();
                    var i = instance_create(x + childXOffset * image_xscale, bbox_bottom - 1, childObject);
                    if (childSprite != noone)
                        i.sprite_index = childSprite;
                    i.image_xscale = image_xscale;
                    
                    image_xscale = storeXS;
                }
            }
        }
    }
    
    if (yspeed &lt; 0)
    {
        if (y &lt; ystart)
        {
            shiftObject(0, ystart - y, 1);
            y=ystart;
            phase = 0;
        }
    }
}
else if (dead)
{
    alarmStop = 0;
    img = 0;
    imgTimer = 0;
    phase = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (dead)
{
    exit;
}

if (iFrames mod 2 == 1)
{
    hitFlashEffect(true,c_white);//d3d_set_fog(true, c_white, 0, 0);
}

if (!ground)
{
    drawSelf();
}
else
{
    draw_sprite_part(sprite_index, image_index, 0, 0, sprite_width,
        sprite_height - 2, x - sprite_xoffset, y - sprite_yoffset);
}

if (iFrames mod 2 == 1)
{
    hitFlashEffect(false);//d3d_set_fog(false, 0, 0, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
