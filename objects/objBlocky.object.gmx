<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprBlockyPiece</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// A bunch of blocks together, this enemy will dance and move forwards, if his vulnerable part is hit.
// Stretch in the editor to alter his size and set a head to 1 to make it vulnerable
// he will fall and the blocks will spread, if he's still alive he will regenerate.

event_inherited();

healthpointsStart = 2;
healthpoints = healthpointsStart;
contactDamage = 8; //surprisingly high contact damage value, consider lowering it in creation code.

category = "shielded";

//@cc
facePlayerOnSpawn = true;

// Enemy specific code
sinIncrement = 0.15; // Using this variable is recommended, please give it an unnecessary amount of attention :)
sinMultiplier = 0.6;
moveSpeed = 0.35;
collapseTimer = 180;
collapsed = false;
catchTimes = 0;
sinCounter = 0;
//@cc set to false to disable turning
canTurn = true;

calibrated = 0;

//@cc 0 = blue; 1 = gray
col = 0;

init = 1;

blockSprite = sprBlockyPiece; // image 1 = head, 0 = body
spraySprite = sprBlockySpray;
if col == 1
{
    blockSprite = sprBlockyPieceGray;
    spraySprite = sprBlockySprayGray;
}
for (var i = 0; i &lt;= 100*sign(image_yscale); i += sign(image_yscale)) //crash fixes hopefully
{
    head[i] = 0; 
}

for (var j = 0; j &lt;= image_yscale; j += sign(image_yscale))
{
    head[j] = 0; 
}
storedYScale = image_yscale;
sprite_index = blockSprite;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if (init)
{
    init = 0;
    if col == 1
    {
        blockSprite = sprBlockyPieceGray;
        spraySprite = sprBlockySprayGray;
    }
}

if (entityCanStep())
{
    if (xcoll != 0)
    {
        image_xscale *= -1;
        x -= sprite_get_width(sprite_index)*image_xscale;
    }
    if (xspeed == 0 &amp;&amp; !collapsed)
    {
        xspeed = moveSpeed * image_xscale;
    }
    if !collapsed
    {
        sinCounter += sinIncrement;
    }
    if (catchTimes &gt;= 3 &amp;&amp; collapsed)
    {
        collapsed = false;
        collapseTimer = 180;
        image_yscale = storedYScale;
        y -= (image_yscale*16) - 16*sign(image_yscale);
        for (var i = 0; i &lt;= image_yscale; i += sign(image_yscale))
        {
            if head[i] == 2
            {
                head[i] = 1;
            }
        }
        sprite_index = blockSprite;
        //image_index = 0;
        sinCounter = 0;
        var prevXScale = image_xscale;
        calibrateDirection();
        if image_xscale != prevXScale
        {
            x -= sprite_get_width(sprite_index)*image_xscale;
        }
        catchTimes = 0;
    }
    
    if (ground &amp;&amp; sprite_index == spraySprite)
    {
        image_index = 1;
        collapseTimer -= 1;
        if (collapseTimer mod 10 == 0 &amp;&amp; collapseTimer &lt;= (10*(storedYScale-1))) //if (collapseTimer == 30 || collapseTimer == 20 || collapseTimer == 10)
        {
            if head[abs(collapseTimer) div 10] != 2 &amp;&amp; collapseTimer &gt;= 0
            {
                var ID = instance_create(x, view_yview[0] + 224 - 16, objBlockySprayRise);
                ID.respawn = false;
                ID.despawnRange = 8;
                ID.canHit = false;
                ID.sprite_index = spraySprite;
                ID.blockyID = id;
                ID.image_xscale = image_xscale;
                if head[collapseTimer div 10] == 1
                {
                    ID.image_index = 0;
                }
                if col == 1
                {
                    ID.sprite_index = sprBlockySprayGray;
                }
            }
        }
    }
}
else
{
    image_speed = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if col == 1
{
    blockSprite = sprBlockyPieceGray;
    spraySprite = sprBlockySprayGray;
}
image_index = 0;
if (collapsed)
{
        collapseTimer = 180;
        if image_yscale != storedYScale
        {
            image_yscale = storedYScale;
            //y -= (image_yscale*16) - 16*sign(image_yscale); 
        }
        for (var i = 0; i &lt;= image_yscale; i += sign(image_yscale))
        {
            if head[i] == 2
            {
                head[i] = 1;
            }
        }
        sprite_index = blockSprite;
        //image_index = 0;
        var prevXScale = image_xscale;
        calibrateDirection();
        if image_xscale != prevXScale
        {
            x -= sprite_get_width(sprite_index)*image_xscale;
        }
        sinCounter = 0;
        collapseTimer = 180;
        collapsed = false;
        catchTimes = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (sprite_index != spraySprite) //&amp;&amp; (!invincible)
{
    if healthpoints &gt; 1
    {
        var canProceed = false;
        for (var i = 0; i &lt;= image_yscale; i += sign(image_yscale))
        {
            if head[i] &amp;&amp; inRange(bboxGetYCenterObject(other.id), y + i*16, y + i*16 + 16) &amp;&amp; (other.object_index != objSparkShock)
            {
                head[i] = 2;
                canProceed = true;
            }
        }
        if canProceed == true
        {
            for (var j = 0; j &lt;= image_yscale-1; j += sign(image_yscale))
            {
                if head[j] != 2
                {
                    block = instance_create(x, y + 16, objBlockySpray);
                    with (block)
                    {
                        sprite_index = other.spraySprite;
                        if other.col == 1
                        {
                            sprite_index = sprBlockyPieceGray;
                        }
                        image_index = 2;
                        image_speed = 0;
                        image_xscale = other.image_xscale;
                    }
                    if head[j] == 1
                    {
                        block.image_index = 0;
                    }
                    block.xspeed = (1 + j*0.5)*image_xscale;
                    block.yspeed = (-2 - 2*j);
                }
            }       
            collapsed = true;
            sprite_index = spraySprite;
            if abs(image_yscale) &gt; 1
            {
                y += 16*sign(image_yscale);
            }
            storedYScale = image_yscale;
            image_yscale = 1;
            image_speed = 0;
            image_index = 0;
            xspeed = 0;
        }
        else
        {
            global.damage = 0;
            other.guardCancel = 1;
            if (other.penetrate &gt; 1)
                other.guardCancel = 2;
        }
    }
}
else
{
    global.damage = 0;
    other.guardCancel = 1;
    if (other.penetrate &gt; 1)
        other.guardCancel = 2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!dead) //had to copy paste from prtEntity draw event to get blocky draw code working, I apologize in advance for this.
{
    if (spawned == -1)
    {
        show_debug_message(object_get_name(object_index) + " drawn without having ever spawned!");
    }
    if ((ceil(iFrames / 2) mod 4) || !iFrames)
    {
        var iceBlinkTime = 42;
        if ((ceil(iFrames / 2) mod 2) || (iceTimer &gt; 0 &amp;&amp; (iceTimer &gt; iceBlinkTime || (iceTimer &lt;= iceBlinkTime &amp;&amp; iceTimer mod 4 == 0))))
        {
            var flashcol = c_white;
            if (iceTimer &gt; 0 &amp;&amp; (iceTimer &gt; iceBlinkTime || (iceTimer &lt;= iceBlinkTime &amp;&amp; iceTimer mod 4 == 0)))
            {
                switch (iceGraphicStyle)
                {
                    case 1:
                        flashcol = 0;
                        break;
                    default:
                        flashcol = make_color_rgb(0, 120, 255);
                        break;
                }
            }
            
            d3d_set_fog(true, flashcol, 0, 0);
            if sprite_index == spraySprite
            {
                draw_sprite_ext(spraySprite, image_index, x, y, image_xscale, sign(image_yscale), image_angle, image_blend, image_alpha);
            }
            else
            {
                for (var i = 0; i &lt; image_yscale; i += sign(image_yscale))
                {
                    var shiftDir = 1;
                    if i/2 == floor(i/2)
                    {
                        shiftDir = -1;
                    }
                    draw_sprite_ext(blockSprite, head[i], x + cos(sinCounter)*sinMultiplier*image_xscale*shiftDir, y + i*sprite_get_height(blockSprite)*sign(image_yscale), image_xscale, sign(image_yscale), image_angle, image_blend, image_alpha);
                }
            }
            d3d_set_fog(false, 0, 0, 0);
            
            if (iceTimer &gt; 0 &amp;&amp; (iceTimer &gt; iceBlinkTime || (iceTimer &lt;= iceBlinkTime &amp;&amp; iceTimer mod 4 == 0)))
            {
                draw_set_blend_mode(bm_add);
                if sprite_index == spraySprite
                {
                    draw_sprite_ext(spraySprite, image_index, x, y, image_xscale, sign(image_yscale), image_angle, image_blend, image_alpha);
                }
                else
                {
                    for (var j = 0; j &lt; image_yscale; j += sign(image_yscale))
                    {
                        var shiftDir = 1;
                        if j/2 == floor(j/2)
                        {
                            shiftDir = -1;
                        }
                        draw_sprite_ext(blockSprite, head[j], x + cos(sinCounter)*sinMultiplier*image_xscale*shiftDir, y + j*sprite_get_height(blockSprite)*sign(image_yscale), image_xscale, sign(image_yscale), image_angle, image_blend, image_alpha);
                    }
                }
                draw_set_blend_mode(bm_normal);
            }
        }
        else
        {
            // Special effect when invincibile. Commented out because enemies being invincibile isnt in megamix
            /*
            if (invincible == true)
            {
                d3d_set_fog(true, c_white, 0, 0);
                draw_sprite_ext(sprite_index, image_index, x, y, image_xscale * 1.075 + (sin(sparkleTimer * 0.15) *.08 * sign(image_xscale)), image_yscale * 1.025 + (sin(sparkleTimer * 0.15) *.08 * sign(image_yscale)), image_angle, image_blend, image_alpha);
                for (var k = 0; k &lt; image_yscale; k += sign(image_yscale))
                {
                    var shiftDir = 1;
                    if k/2 == floor(k/2)
                    {
                        shiftDir = -1;
                    }
                    draw_sprite_ext(blockSprite, head[k], x + cos(sinCounter)*sinMultiplier*image_xscale*shiftDir, y + k*sprite_get_height(blockSprite)*sign(image_yscale), 
                        image_xscale * 1.075 + (sin(sparkleTimer * 0.15) *.08 * sign(image_xscale)), sign(image_yscale) * 1.025 + (sin(sparkleTimer * 0.15) *.08 * sign(image_yscale)), 
                        image_angle, image_blend, image_alpha);
                }
                d3d_set_fog(false, 0, 0, 0);
            }
            */
            if sprite_index == spraySprite
            {
                draw_sprite_ext(spraySprite, image_index, x, y, image_xscale, sign(image_yscale), image_angle, image_blend, image_alpha);
            }
            else
            {
                for (var l = 0; l &lt; image_yscale; l += sign(image_yscale))
                {
                    var shiftDir = 1;
                    if l/2 == floor(l/2)
                    {
                        shiftDir = -1;
                    }
                    draw_sprite_ext(blockSprite, head[l], x + cos(sinCounter)*sinMultiplier*image_xscale*shiftDir, y + l*sprite_get_height(blockSprite)*sign(image_yscale), image_xscale, sign(image_yscale), image_angle, image_blend, image_alpha);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
