<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprKeyCoinManager</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///controls counting the key coins you've collected in the room it's placed in
//one is also automatically generated in any room that has key coins in it
event_inherited();

grav = 0;
blockCollision = false;
canHit = false;
respawnRange = -1;
despawnRange = -1;
visible = true;


//@cc awards a key to the player at these intervals of coins collected
//if nothing is specified, will award one key for all the coins in the room
//specified as an array. use the makeArray() script. e.g. coinKeyAwards = makeArray(3, 6, 9);
//the interval between these must be at least one!
coinKeyAwards = undefined;

//@cc changes the type of display shown in the bottom-left corner of the screen
//0: same as engine key coins. the difference between key awards is marked with brackets
//1: displays the amount of coins you have, versus the amount you need for the next key
//all else: no display. player is left sad and alone In a cruel Universe
displayMode = 0;

//@cc the number of coins in the room. 
//this is calculated automatically in most circumstances,
//but you may have to specify this if the coin collection spans multiple sections
coinCount = undefined;

//don't touch these
init = false;
coinsObtained = 0;
awardIndex = 0;
coinAnimTimer = undefined;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if !global.frozen &amp;&amp; (coinAnimTimer != undefined)
{
    //obtainBlinkTimer--;
    //progress animation
    var i = coinKeyAwards[array_length_1d(coinKeyAwards) - 1];
    if typeof(coinAnimTimer) == "array"
    {
        for (var a = 0; a &lt; i; a++)
            coinAnimTimer[a]--;
    }
    else
        coinAnimTimer--;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if(spawned &amp;&amp; !init)
    event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Automatically count red coins, if needed

if coinCount == undefined
{
    //count coins
    coinCount = 0;
    with(objKeyCoin)
    {
        controller = other;
        other.coinCount++;
    }
}

//set awards to one key for getting all the coins, if awards are unset
if coinKeyAwards == undefined
    coinKeyAwards = makeArray(coinCount);

//create array for animations on individual gui coins, if necessary
if displayMode = 0
    coinAnimTimer = allocateArray(coinKeyAwards[array_length_1d(coinKeyAwards) - 1]);   //coins past the last award aren't animated, so we don't need to store animation values for them
else
    coinAnimTimer = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Validate CC variables

//make sure the awards are incremental
for (var b = 1; b &lt; array_length_1d(coinKeyAwards); b++)
    assert(coinKeyAwards[b] &gt; coinKeyAwards[b - 1], 
        "coinKeyAwards non-incrementing on " + object_get_name(object_index) + " at " + string(x) + "," + string(y));
//if there are no key coins in the room at all, die and throw nonfatal error
if coinCount &lt;= 0
{
    printErr("deleted " + object_get_name(object_index) + " with no key coins assigned to it at " + string(x) + "," + string(y));
    instance_destroy();
    exit;
}
//if there aren't enough key coins in the room for the keys this gives, throw a nonfatal error
if (coinCount &lt; coinKeyAwards[array_length_1d(coinKeyAwards) - 1])
    printErr("highest coinKeyAwards (" + string(coinKeyAwards[array_length_1d(coinKeyAwards) - 1]) + ") is higher than provided key coins (" + string(coinCount) + ") on " + object_get_name(object_index) + " at " + string(x) + "," + string(y));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw the red coin HUD

if (coinAnimTimer == undefined)
    exit;

var drawX = view_xview;
var drawY = view_yview + view_hview - 8;

switch(displayMode)
{
    case 0: //engine-style key coins
        var c = 0;
        var groupLightUp;
        var groupCollected;
        //draw coins in 'groups' that are divided between awards
        for (var group = 0; group &lt; array_length_1d(coinKeyAwards); group++;)
        {
            groupLightUp = (coinsObtained == coinKeyAwards[group]);
            groupCollected = (coinsObtained &gt;= coinKeyAwards[group]) * 2;
            //blink when group is completed
            if coinAnimTimer[coinKeyAwards[group] - 1] &gt; 0
                d3d_set_fog(true, c_white, 0, 0);
            //open bracket
            draw_sprite(sprKeyCoinHUDBracket, 2 - groupCollected, drawX, drawY);
            drawX += 4;
            //draw coins
            for (c = c; c &lt; coinKeyAwards[group]; c++)
            {
                //coin icon turns white briefly after being collected
                if coinAnimTimer[c] &gt; 0
                    draw_sprite(sprKeyCoinHUD, 2, drawX, drawY)
                else
                    draw_sprite(sprKeyCoinHUD, !(coinsObtained &gt; c), drawX, drawY)
                drawX += 8;
            }
            //close bracket
            draw_sprite(sprKeyCoinHUDBracket, 3 - groupCollected, drawX, drawY);
            drawX += 4;
            //clear flash
            d3d_set_fog(false, 0, 0, 0);
        }
        //any coins left over can get drawn, too
        for (c = c; c &lt; coinCount; c++)
        {
            draw_sprite(sprKeyCoinHUD, !(coinsObtained &gt; c), drawX, drawY)
            drawX += 8;
        }
        break;
    
    case 1: //you have _ / 100
        //get the next upcoming award
        var nextAward = string(coinKeyAwards[min(awardIndex, array_length_1d(coinKeyAwards) - 1)]);
        //get current coin count, append zeroes until it has the same digits as next award
        var leadingSpaces = string_length(nextAward);
        var c = string(coinsObtained);
        while string_length(c) &lt; leadingSpaces
            c = "0" + c;
        
        //draw
        draw_sprite(sprKeyCoinHUD, (coinAnimTimer &gt; 0) * 2, drawX, drawY);
        draw_text(drawX + 12, drawY + 8, c + "/" + nextAward);
        break
    
    //you can add more draw formats if you can think of any worthwhile ones, i guess
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
