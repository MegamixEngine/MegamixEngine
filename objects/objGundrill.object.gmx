<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprGundrill</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>prtMiniBoss</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Creation code (all optional):
// image_yscale: -1 // set in editor! - if image_yscale is set to -1, then gundrill will come out of the cieling when you first encounter him rather than the floor.

event_inherited();
respawn = true;
doesIntro = false;
healthpointsStart = 12;
healthpoints = healthpointsStart;
contactDamage = 6;
blockCollision = 0;
grav = 0;
facePlayerOnSpawn = true;
category = "bulky, flying, rocky";

despawnRange = -1;
delayDisplay = 2;
child = noone;
startMoving = false;


realX = x;
realY = y;
offsetX = 0;
prepareCollision = false;

// Enemy specific code
image_speed = 0;
image_index = 0;
phase = -1;
attackTimer = 0;
attackTimerMax = 8;
animTimer = 0;
setY = 0;
shotsFired = 1;
dir = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if (entityCanStep())
{
    if (delayDisplay &gt; 0)
    {
        delayDisplay--;
    }
    dir = image_xscale; // since mini bosses have weird direction code, force the direction here.
    image_index += 0.25;
    
    // these two variables are used temporarily later.
    var offYU;
    var offYD;
    if (image_yscale == 1) // this determines the collision box for gundrill later.
    {
        offYU = 16;
        offYD = 0;
    }
    else
    {
        offYU = 0;
        offYD = 16;
    }
    
    switch (phase)
    {
        case -1: // initalization 
            for (var i = 0; i &lt; view_hview; i++) // find the nearest floor or cieling
            {
                y += sign(image_yscale);
                delayDisplay = 2;
                if (collision_rectangle(x - 16, y - 16, x + 16, y + 16, objSolid, false, true))
                {
                    y += 32 * image_yscale; // embed self into floor or cieling.
                    var cover = instance_create(x - 16, y - 16, objGundrillCover); // create coverup - this coverup uses the graphics from the tiles beneath it.
                    cover.parent = id;
                    child = cover.id;
                    attackTimer = 0;
                    shotsFired = 0;
                    facePlayer = true;
                    phase = 0;
                    
                    if (image_yscale == -1)
                    {
                        child.ceilOrFloor = 1;
                    }
                    break;
                }
            }
            break;
        case 0: // drill from rocks 
            facePlayer = false;
            var upDown;
            if (instance_exists(child)) // since the coverup object's y position is at its 0 point, to make things easier we store whether or not we need to offset things by 32 pixels or not.
            {
                if (child.ceilOrFloor == 0)
                {
                    upDown = 0;
                }
                else
                {
                    upDown = 32;
                }
            }
            attackTimer++;
            if (place_meeting(x, y, child) &amp;&amp; attackTimer mod 4 == 0 &amp;&amp; (shotsFired &lt; 2)) // create tell
            {
                instance_create(x - 3 + irandom(6), child.y + (upDown) - (3 + irandom(3)), objExplosion);
            }
            if (attackTimer mod 32 == 31 &amp;&amp; (shotsFired &lt; 2)) // create debry
            {
                playSFX(sfxCompactor);
                for (var i = 0; i &lt; 5; i++)
                {
                    if (i != 2) // gundrill does not create a "middle" projectile
                    {
                        var inst = instance_create(x, child.y + upDown, objGundrillRock);
                        inst.xspeed = -1.5 + i * 0.75;
                        if (child.ceilOrFloor == 1) // if creating from the cieling, there should be no initial vertical momentum
                        {
                            inst.yspeed = 0;
                        }
                    }
                }
                shotsFired++;
            }
            if (shotsFired == 2)
            {
                startMoving = true;
            }
            if (startMoving &amp;&amp; attackTimer &gt;= 80)
            {
                if (instance_exists(child))
                {
                    if (collision_rectangle(x - 16, y - 16, x + 16, y + 16, child, false, true))
                    {
                        offsetX = -2 + irandom(4);
                        x = realX + offsetX;
                        if (startMoving)
                            yspeed = -image_yscale * 0.5;
                    }
                    else
                    {
                        yspeed = -image_yscale * 1;
                        x = realX;
                        offsetX = 0;
                        if (prepareCollision == 0)
                        {
                            prepareCollision = 1;
                        }
                        with (child) // delay the death of child object to prevent it from being destroyed too early
                        {
                            if (deathTimer &lt;= 0)
                            {
                                instance_destroy();
                            }
                        }
                    }
                }
                
                if (collision_rectangle(x - 16, y - offYU, x + 16, y + offYD, objSolid, false, true) &amp;&amp; prepareCollision == 1) // create coverup object when gundrill hits the opposite side
                {
                    prepareCollision = 2;
                    shotsFired = 0; // reset shots fired so gundrill can create more projectiles after its crossed the screen.
                    
                    var cover = instance_create(x - 16, y - 16 + (-32 * image_yscale), objGundrillCover);
                    cover.parent = id;
                    child = cover.id;
                    if (image_yscale == 1)
                    {
                        child.ceilOrFloor = 1;
                    }
                }
                if (instance_exists(child)) // when gundrill is in place, change phase
                {
                    if (prepareCollision &gt;= 2 &amp;&amp; ((y &lt;= child.y + 16 &amp;&amp; image_yscale == 1) || y &gt;= child.y + 16 &amp;&amp; image_yscale == -1))
                    {
                        prepareCollision = 0;
                        yspeed = 0;
                        setY = child.y + 16;
                        y = setY;
                        phase = 1;
                    }
                }
            }
            break;
        case 1: // change places!! - randomise the location of gundrill 
            delayDisplay = 99999; // renders gundrill invisible and invincible during this entire time
            canHit = false;
            contactDamage = 0;
            var oldMask = mask_index;
            mask_index = mskGunDrillBox; // since gundrill's actual mask is smaller than the collisiion block, temporarily change it.
            
            // we find how far away the left side of the screen is, and how far away the right side of the screen is.
            var left = 0;
            var right = 0;
            for (var i = 0; i &lt; view_wview / 16; i++)
            {
                y = setY + 40 * image_yscale;
                x = realX - i * 16;
                if (collision_rectangle(x - 16, y - 8, x + 16, y + 8, objSolid, false, true))
                {
                    left = ceil(i / 2) - 1;
                    break;
                }
            }
            for (var i = 0; i &lt; view_wview / 16; i++)
            {
                y = setY + 40 * image_yscale;
                x = realX + i * 16;
                if (collision_rectangle(x - 16, y - 8, x + 16, y + 8, objSolid, false, true))
                {
                    right = floor(i / 2) - 1;
                    break;
                }
            }
            x = realX;
            y = setY;
            
            // randomise location
            var nextPos = 0;
            for (var i = 0; i &lt; 256; i++) // we do a for loop rather than a while loop as a sort of idiot proofing.
            {
                if (nextPos == 0) // make sure gundrill has actually moved
                {
                    nextPos = -left;
                    nextPos += irandom(left + right);
                }
                else
                {
                    break;
                }
            }
            
            // set gundrill to its new position and flip its graphics
            realX += nextPos * 32;
            x = realX;
            image_yscale *= -1;
            mask_index = oldMask;
            phase = 2;
            break;
        case 2: // setup code for changed direction 
            with (child) // destroy old coverup and create a new coverup at the gundrill's latest location
            {
                instance_destroy();
            }
            var cover = instance_create(x - 16, y - 16, objGundrillCover);
            cover.parent = id;
            child = cover.id;
            if (image_yscale == -1)
            {
                child.ceilOrFloor = 1;
            }
            shotsFired = 0;
            attackTimer = -64;
            delayDisplay = 2;
            phase = 3;
            break;
        case 3: // wait before moving 
            facePlayer = true;
            attackTimer++;
            if (attackTimer &gt;= 0) // reset variables and continue fight!
            {
                canHit = true;
                contactDamage = 6;
                phase = 0;
            }
            break;
    }
}
else if (!insideView())
{
    image_index = 0;
    y = ystart;
    x = xstart;
    canHit = true;
    contactDamage = 6;
    attackTimer = 0;
    phase = -1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ((image_yscale == 1 &amp;&amp; (bboxGetYCenterObject(other.id) &lt; y - 8))
    ||
    (image_yscale == -1 &amp;&amp; (bboxGetYCenterObject(other.id) &gt; y + 8)))
{
    other.guardCancel = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>facePlayerOnSpawn = false;
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (phase != -1 &amp;&amp; delayDisplay == 0)
    event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
