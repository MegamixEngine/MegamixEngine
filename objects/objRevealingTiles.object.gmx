<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprRevealingTiles</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtAlwaysActive</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// makes all tiles on a particular layer invisible.
// when mega man is near those tiles in the section
// this is placed in, they become visible.

//@cc tiles on this layer will be invisible
layer = 1000000;

//@cc number of revealing objects
revealersN = 1;

//@cc objects which reveal tiles
revealers[0] = objMegaman;

//@cc radius about these objects in which the light is revealed
radius[0] = 32;

sectionSurface = noone;
sectionSurfaceMask = noone;
scanned = false;
skipDraw=false;
tiles = makeArray();

//@cc whether to check if revealers are alive.
checkAlive = true;

prevWeather = global.telTelWeather;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!insideSection(x,y))
{
    exit;
}
skipDraw=false;
if(instance_exists(objTelTelWeatherControl))
{
    if(prevWeather!=global.telTelWeather&amp;&amp;global.telTelWeather==2)
    {
        tiles = tile_get_ids_at_depth(layer);
        tile_layer_show(layer);
        for(var i=array_length_1d(tiles)-1;i&gt;=0;--i)
        {
            var tile = tiles[i];
            var tx = tile_get_x(tile);
            var ty = tile_get_y(tile);
            var st = instance_create(tx,ty,objTelTelSnowTile);
            st.tileTop = tile_get_top(tile);
            st.tileLeft = tile_get_left(tile);
            st.tileBG = tile_get_background(tile);
            st.tileWidth = tile_get_width(tile);
            st.tileHeight = tile_get_height(tile);
            st.depth = layer-1;
            st.tile = tile;
            
            if(!tile_exists(tile_layer_find(layer,tx,ty-8)))
            {
                st.isGround=true;
            }
            
        }
        skipDraw=true;
    }
    else if(prevWeather!=global.telTelWeather)
    {
        scanned=false;
    }
    
}
prevWeather = global.telTelWeather;
if(global.telTelWeather==2)
{
    skipDraw=true;
    exit;
}
if (!scanned)
{
    tiles = tile_get_ids_at_depth(layer);
    tile_layer_hide(layer);
    depth = layer;
    setSection(x + 8, y + 8, false);
    
    for (var i = 0; i &lt; array_length_1d(tiles); i++)
    {
        var tile = tiles[i];
        if (tile_get_x(tile) &gt; sectionRight)
        {
            tiles[i] = -1;
        }
        if (tile_get_x(tile) + tile_get_width(tile) &lt; sectionLeft)
        {
            tiles[i] = -1;
        }
        if (tile_get_y(tile) &gt; sectionBottom)
        {
            tiles[i] = -1;
        }
        if (tile_get_y(tile) + tile_get_height(tile) &lt; sectionTop)
        {
            tiles[i] = -1;
        }
    }
    
    var oldTiles = tiles;
    tiles = makeArray();
    var j = 0;
    for (var i = 0; i &lt; array_length_1d(oldTiles); i++)
    {
        if (oldTiles[i] != -1)
        {
            tiles[j++] = oldTiles[i];
        }
    }
    
    scanned = true;
}

// allocate surface
if (!surface_exists(sectionSurface) || !surface_exists(sectionSurfaceMask))
{
    var sectionWidth = sectionRight - sectionLeft;
    var sectionHeight = sectionBottom - sectionTop;
    surface_free(sectionSurface);
    surface_free(sectionSurfaceMask);
    
    sectionSurface = surface_create(sectionWidth, sectionHeight);
    sectionSurfaceMask = surface_create(sectionWidth, sectionHeight);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>surface_free(sectionSurface);
surface_free(sectionSurfaceMask);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// surface (tiles)
if(!insideSection(x,y))
{
    exit;
}
if(skipDraw)
    exit;
surface_set_target(sectionSurface);
draw_clear_alpha(c_white, 0);
for (var i = 0; i &lt; array_length_1d(tiles); i++)
{
    var tile = tiles[i];
    draw_background_part_ext(
        tile_get_background(tile),
        tile_get_left(tile),
        tile_get_top(tile),
        tile_get_width(tile),
        tile_get_height(tile),
        tile_get_x(tile) - sectionLeft,
        tile_get_y(tile) - sectionTop,
        tile_get_xscale(tile),
        tile_get_yscale(tile),
        tile_get_blend(tile),
        tile_get_alpha(tile)
    );
}
surface_reset_target();

// mask (reveals tiles)
surface_set_target(sectionSurfaceMask);
draw_clear_alpha(c_white, 0);
draw_set_color(c_white);
draw_set_alpha(1);
draw_set_circle_precision(64);
for (var i = 0; i &lt; revealersN; i++)
{
    with (revealers[i])
    {
        if (other.checkAlive)
        {
            if (dead)
            {
                continue;
            }
        }
        
        // draw circular mask
        draw_circle(
            (bbox_left + bbox_right) / 2 - other.sectionLeft,
            (bbox_top + bbox_bottom) / 2 - other.sectionTop,
            other.radius[min(i, array_length_1d(other.radius) - 1)], false);
    }
}

// apply tiles to mask
draw_set_blend_mode_ext(bm_dest_alpha, bm_zero);
draw_surface(sectionSurface, 0, 0);
draw_set_blend_mode(bm_normal);
surface_reset_target();

// draw surface on screen
draw_surface(sectionSurfaceMask, sectionLeft, sectionTop);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
