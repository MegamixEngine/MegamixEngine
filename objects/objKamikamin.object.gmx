<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprKamikamin</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// A fake treasure chest that leaps toward the player when damaged. Acts as a normal solid object until then.
/// If it touches the player, it will bite them continuously until shaken off by rapidly turning left and right.
/// Best reserved for puzzle challenges and devious surprises.

event_inherited();

healthpointsStart = 1;
healthpoints = healthpointsStart;
contactDamage = 1;

facePlayer = false;
facePlayerOnSpawn = false;
isSolid = 1;
myItem = 0; // I THINK they don't drop items in MM&amp;B?
isTargetable = false;
killOverride = false;
bubbleTimer = -1;

// Enemy Specific Code
kamikaminRespawnType = true;
shakeOffRespawn = false; // Do we respawn if shaken off?

// @cc - Determines delay between reveal and attack phases
attackDelay = 30;

// @cc - How many button presses does it take to shake me off?
shakeLimit = 20;

imgIndex = 0;
imgSpd = 0.2;
phase = 0;
delayTimer = 0; // Attack delay counter
shakeCounter = 0; // Button input counter
initXscale = image_xscale;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (entityCanStep())
{
    switch (phase)
    {
        case 0: // Idle (do nothing)
            break;
        case 1: // Reveal delay
            delayTimer++;
            if (delayTimer mod 2 == 1)
                visible = false;
            else
                visible = true;
            if (delayTimer &gt;= attackDelay)
            {
                phase = 2;
                visible = true;
            }
            break;
        case 2: // Jump around
            if (ground)
            {
                yspeed = choose(-4, -4, -6) * image_yscale;
                calibrateDirection();
                xspeed = 2 * image_xscale;
                playSFX(sfxBallBounce);
            }
            if (ycoll != 0) &amp;&amp; (!ground)
            {
                yspeed = -ycoll;
                playSFX(sfxBallBounce);
            }
            if (xcoll != 0)
            {
                xspeed = -xcoll;
                playSFX(sfxBallBounce);
            }
            if (instance_exists(target)) &amp;&amp; (place_meeting(x,y,target)) // Bite onto Mega Man
            {
                phase = 3;
                canHit = false;
                blockCollision = false;
                grav = 0;
                xspeed = 0;
                yspeed = 0;
            }
            break;
        case 3: // mmm yummy mega man, much better than cement
            if (instance_exists(target)) // Stay on target
            {
                x = target.x - (5 * image_xscale);
                y = target.y - (8 * target.image_yscale);
                
                if (global.keyLeftPressed[target.playerID]) || (global.keyRightPressed[target.playerID])
                || (global.keyUpPressed[target.playerID]) || (global.keyDownPressed[target.playerID])
                || (global.keyJumpPressed[target.playerID])
                {
                    shakeCounter++;
                }
                if (shakeCounter &gt;= shakeLimit) // Be shaken off after enough mashing
                {
                    phase = 4;
                    grav = 0.25 * image_yscale;
                    blockCollision = true;
                    image_xscale *= -1;
                    xspeed = 1 * image_xscale;
                    yspeed = -4 * image_yscale;
                    playSFX(sfxBallBounce);
                }
            }
            break;
        case 4: // whomp get yeeted into oblivion, nerd
            if (xcoll != 0) || (ycoll != 0) // Die
            {
                dead = 1;
                instance_create(bboxGetXCenter(), bboxGetYCenter(),objExplosion);
                playSFX(getGenericSFX(SFX_ENEMYHIT));
                if (!shakeOffRespawn)
                    instance_destroy(); // don't respawn
                else
                    dead = 1;
            }
            break;
    }
    
    // Animation
    if (phase &gt;= 2)
    {
        imgIndex += imgSpd;
        if (imgIndex &gt;= 4)
            imgIndex = 1;
    }
}
image_index = imgIndex div 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if (spawned)
{
    imgIndex = 0;
    phase = 0;
    delayTimer = 0;
    shakeCounter = 0;
    grav = 0.25 * image_yscale;
    canHit = true;
    blockCollision = true;
    visible = true;
    isSolid = 1;
    image_xscale = initXscale; // Respawn w/ initial xscale if despawned
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (phase == 0)
{
    if (global.damage != 0)
    {
        phase = 1;
        imgIndex = 1;
        isSolid = 0;
        
        global.damage = 0;
        playSFX(getGenericSFX(SFX_ENEMYHIT));
        with (other)
        {
            if (pierces &lt; 2)
                instance_destroy();
        }
    }
}
if (phase == 1)
{
    other.guardCancel = 2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dead = 1;

var ex = instance_create(bboxGetXCenter(), bboxGetYCenter(), objExplosion);
ex.myItem = myItem;

if(kamikaminRespawnType){
    instance_destroy(); // don't respawn
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
