<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMM3TileBG</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Place this down over a tile on the set layer (tile) and it will shift left or right
// depending on the xscale of the object in the editor.

// Creation code (all optional):
// tile = &lt;number&gt;. Depth of the layer of tiles that needs to be shifted.
// spd = &lt;number&gt;. Speed of the tile shifting. Will be multiplied by image_xscale.

// it took me literally almost three full days to fix this and it was extremely painful
// please don't have me do this again :(
// -snoruntpyro

event_inherited();

canHit = false;
grav = 0;
blockCollision = 0;
bubbleTimer = -1;

respawnRange = -1;
despawnRange = -1;

stepInit = 1;
drawInit = 1;

// section boundaries
_sl = x;
sr = x;
th = 0;
tw = 0;
tT = 0;
tl = 0;
tb = 0;

tileID = 0;
xshift = 0;

// customizeable variables
tile = 30;
spd = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// initialize section + direction
if (stepInit)
{
    // direction setting
    if (image_xscale &lt; 0)
    {
        image_xscale = 1;
        x -= 16;
        xstart = x;
        xshift = -1;
    }
    else
    {
        xshift = 1;
    }
    
    stepInit = 0;
}

// actual shifting
if (!global.frozen &amp;&amp; !global.timeStopped &amp;&amp; tileID &gt; 0)
{
    // grab section boundaries, even if the game is frozen
    if (instance_exists(objMegaman))
    {
        _sl = global.sectionLeft;
        sr = global.sectionRight;
    }
    
    // loop around the screen
    if (x &gt; (sr - 16) &amp;&amp; xshift &gt; 0 &amp;&amp; xspeed != 0)
    {
        x -= sr - _sl;
    }
    if (x &lt; (_sl) &amp;&amp; xshift &lt; 0 &amp;&amp; xspeed != 0)
    {
        x += sr - _sl;
    }
    
    // ughhh failsafe
    if ((x &lt; (_sl - 8) &amp;&amp; xshift &lt; 0) || (x &gt;= (sr - 8) &amp;&amp; xshift &gt; 0))
    {
        x = xstart;
        y = ystart;
        xspeed = 0;
    }
    
    // move depending on xshift variable
    if (xspeed == 0 &amp;&amp; _sl != sr &amp;&amp; insideSection(x, y) &amp;&amp; insideSection(x + 1, y))
    {
        xspeed = spd * xshift;
    }
    
    // this double inside section check probably looks really weird but that's
    // actually part of how i fixed this damn object from clipping into the wrong section.
    // don't question anything
    
    // this is a really hacky solution to a bug where mega man's speed would get messed up
    // if he was standing on multiple tile slides at a time. usually, objects will
    // instead combine with others next to them and increase their size to fix this
    // (e.g. conveyors) as well as improve performance, but doing this here would break
    // the looping effect. sorry ;-;
    
    with (prtEntity)
    {
        if (blockCollision &amp;&amp; grav != 0)
        {
            var gravDir = sign(grav);
            
            with (other)
            {
                if (isSolid)
                {
                    if (place_meeting(x + 16, y, objTileScrollSolid))
                    {
                        var myID = id;
                        var otherID = instance_place(x + 16, y, objTileScrollSolid)
                        
                        .id;
                        if (place_meeting(x, y - 1 + (17 * (gravDir == -1)), other) &amp;&amp; place_meeting(otherID.x, otherID.y - 1 + (17 * (gravDir == -1)), other))
                        {
                            with (other)
                            {
                                shiftObject(-myID.xspeed, 0, 1);
                                
                                // Why does it have to be negative?
                                // Don't ask questions you aren't prepared to know the answers to.
                                // : )
                            }
                        }
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// don't draw + reset position if section switching is happening
if (instance_exists(objSectionSwitcher))
{
    x = xstart;
    y = ystart;
    despawnRange = 0; // despawn on screen transition
    respawnRange = 0;
    xspeed = 0;
    exit;
}

// reset to defaults
respawnRange = -1;
despawnRange = -1;

// set depth to be the same as the tile layer
depth = tile;

// finding the tile + setting direction
if ((drawInit || tileID &lt;= 0) &amp;&amp; !stepInit)
{
    tileID = tile_layer_find(tile, x + 8, y + 8);
    if (tileID)
    {
        if (x == tile_get_x(tileID) &amp;&amp; y == tile_get_y(tileID))
        {
            tb = tile_get_background(tileID);
            tl = tile_get_left(tileID);
            tT = tile_get_top(tileID);
            tw = tile_get_width(tileID);
            th = tile_get_height(tileID);
            tile_delete(tileID);
        }
        else
        {
            tileID = 0;
        }
    }
    
    drawInit = 0;
}

// draw found tile
if (tileID &amp;&amp; xspeed != 0)
{
    var drawx, drawy;
    
    // determine rounding method
    if (sign(image_xscale) &lt; 0)
    {
        drawx = floor(x);
        drawy = floor(y);
    }
    else
    {
        drawx = ceil(x);
        drawy = ceil(y);
    }
    
    draw_background_part(tb, tl, tT, tw, th, drawx, drawy);
    if (_sl != sr)
    {
        draw_background_part(tb, tl, tT, tw, th, drawx - (sr - _sl), drawy);
        draw_background_part(tb, tl, tT, tw, th, drawx + (sr - _sl), drawy);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
