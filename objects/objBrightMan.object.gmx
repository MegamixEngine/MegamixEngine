<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprBrightMan</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialization
event_inherited();

healthpointsStart = 28;
healthpoints = healthpointsStart;
pose = sprBrightManIntro;
poseImgSpeed = 3.5 / 60; //5 / 60;
contactDamage = 8;

phase = 0; //0 = idle; 1 = jump; 2 = shoot;
attackTimer = 0;
// Shooting Bullets
bulletYSpeeds[0] = -1;
bulletYSpeeds[1] = 0;
bulletYSpeeds[2] = 1;
bulletCount = 3;
bulletIndex = 0;
// Targeting
targetX = x;
targetDist = 0;
// Flash Stopper Stuff
flashHPPoints = makeArray(16, 8, 4);
flashLock = allocateArray(global.playerCount, false);
flashTimer = 0;
hasFlashed = false;
// @cc - If true, Bright Man can jump at player after Flash Stopper is used.
// If you enable this, you will never see the light of Heaven.
flashJump = false;
//
animIndex = 0;

// Health Bar
healthBarPrimaryColor[1] = $26;
healthBarSecondaryColor[1] = $30;

// Music
music = "Mega_Man_4.nsf";
musicType = "VGM";
musicTrackNumber = 17;

// Damage Table
enemyDamageValue(objBusterShot, 1);
enemyDamageValue(objBusterShotHalfCharged, 1);
enemyDamageValue(objBusterShotCharged, 3);
enemyDamageValue(objBusterShotHalfChargedProto, 1);
enemyDamageValue(objBusterShotChargedProto, 3);

// MaGMML3
enemyDamageValue(objSparkChaser, 1);
enemyDamageValue(objLaserTrident, 1);
enemyDamageValue(objWaterShield, 2);
enemyDamageValue(objTornadoBlow, 6);
enemyDamageValue(objThunderBeam, 0);
enemyDamageValue(objBreakDash, 2);
enemyDamageValue(objMagneticShockwave, 2);
enemyDamageValue(objIceWall, 1);

reflectedDamage = -1;
if (reflectedDamage &gt; -1) 
    enemyDamageValue(prtEnemyProjectile, reflectedDamage);

// MaGMML2
enemyDamageValue(objHornetChaser, 1);
enemyDamageValue(objJewelSatellite, 2);
enemyDamageValue(objGrabBuster, 0);
enemyDamageValue(objTripleBlade, 1);
enemyDamageValue(objWheelCutter, 4);
enemyDamageValue(objSlashClaw, 1);
enemyDamageValue(objSakugarne, 2);
enemyDamageValue(objSuperArrow, 0);
enemyDamageValue(objWireAdapter, 1);

// MaGMML1
enemyDamageValue(objMetalBlade, 0);
enemyDamageValue(objGeminiLaser, 4);
enemyDamageValue(objSolarBlaze, 1);
enemyDamageValue(objTopSpin, 1);
enemyDamageValue(objThunderWool, 0);
enemyDamageValue(objPharaohShot, 1);
enemyDamageValue(objBlackHoleBomb, 1);
enemyDamageValue(objMagicCard, 1);

// MaG48HMML
enemyDamageValue(objFlameMixer, 2);
enemyDamageValue(objRainFlush, 4);
enemyDamageValue(objSparkShock, 0);
enemyDamageValue(objSearchSnake, 1);
enemyDamageValue(objTenguBlade, 1);
enemyDamageValue(objTenguDash, 1);
enemyDamageValue(objTenguDisk, 1);
enemyDamageValue(objSaltWater, 1);
enemyDamageValue(objConcreteShot, 1);
enemyDamageValue(objHomingSniper, 1);

// MaG24HMML
enemyDamageValue(objWaterWave, 4);
enemyDamageValue(objSuperArmBlockProjectile, 2);
enemyDamageValue(objSuperArmDebris, 2);
enemyDamageValue(objChillSpike, 1);
enemyDamageValue(objChillSpikeLanded, 1);

// Misc.
enemyDamageValue(objPowerStone, 2);
enemyDamageValue(objPlantBarrier, 2);
enemyDamageValue(objBlockDropper, 2);
enemyDamageValue(objIceSlasher, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Step Event
event_inherited();

if (!entityCanStep() || !isFight)
    exit;

if (sprite_index == pose)
    sprite_index = sprBrightMan;

if (instance_exists(target)) {
    targetX = target.x;
    targetDist = abs(x - target.x);
}

switch (phase) {
    case 0: // Idle
        if (attackTimer == 0)
            calibrateDirection();
        
        image_index = 0;
        attackTimer++;
        
        if (attackTimer &gt;= 30) {
            attackTimer = 0;
            
            if (arrayContains(flashHPPoints, healthpoints) &amp;&amp; !hasFlashed)
                phase = 3;
            else
            {
                if (!flashJump) &amp;&amp; (flashTimer &gt; 0) // Do not jump during Flash Stopper if option disabled
                    phase = 2;
                else if (targetDist &gt; 128)
                    phase = 1 + ((random(1) &lt; 0.625));
                else if (targetDist &gt; 64)
                    phase = choose(1, 2);
                else // targetDist &lt;= 64
                    phase = 1 + (random(1) &gt;= 0.625);
            }
        }
        break;
    
    case 1: // Jump
        if (attackTimer == 0) {
            calibrateDirection();
            image_index = 3;
            attackTimer++;
            yspeed = -7;
            xspeed = (targetX - x) / abs(2 * yspeed / gravAccel);
        } else if (ground) {
            xspeed = 0;
            yspeed = 0;
            attackTimer = 0;
            phase = 0;
        }
        break;
    
    case 2: //Shoot
        if (attackTimer == 0)
            calibrateDirection();
        if (attackTimer == 5) {
            var bullet = entityCreateChild(17, 4, objEnemyBullet);
            bullet.parent = id;
            bullet.contactDamage = 4;
            bullet.xspeed = 5 * image_xscale;
            bullet.yspeed = bulletYSpeeds[bulletIndex];
            bulletIndex++;
        }
        
        attackTimer++;
        image_index = (4 + (attackTimer &gt;= 5)) * (attackTimer &lt;= 12);
        
        if (bulletIndex &lt; bulletCount) {
            if (attackTimer &gt;= 28)
                attackTimer = 0;
        } else if (attackTimer &gt;= 12) {
            arrayShuffle(bulletYSpeeds);
            bulletIndex = 0;
            attackTimer = 0;
            phase = 0;
        }
        break;
    
    case 3: // Flash Stopper
        if (animIndex &lt;= 0)
            animIndex += 1/10;
        else
            animIndex += 1/6;
        animIndex = min(animIndex, 6);
        
        switch (floor(animIndex)) {
            case 0: image_index = 1; break;
            case 1: case 3: image_index = 6; break;
            case 2: image_index = 7; break;
            default: image_index = 8 + floor(animIndex) - 4; break;
        }
        
        attackTimer++;
        
        if (attackTimer == 48) {
            screenFlash(16);
            flashTimer = 240;
            hasFlashed = true;
            playSFX(sfxFlashStopper);
            
            with (objMegaman) {
                xspeed = 0;
                yspeed = 0;
                
                other.flashLock[playerID] = lockPoolLock(localPlayerLock[PL_LOCK_MOVE],
                    localPlayerLock[PL_LOCK_TURN],
                    localPlayerLock[PL_LOCK_SLIDE],
                    localPlayerLock[PL_LOCK_SHOOT],
                    localPlayerLock[PL_LOCK_CLIMB],
                    localPlayerLock[PL_LOCK_SPRITECHANGE],
                    localPlayerLock[PL_LOCK_GRAVITY],
                    localPlayerLock[PL_LOCK_JUMP],
                    localPlayerLock[PL_LOCK_CHARGE]);
            }
        }
        
        if (attackTimer &gt;= 72)
        {
            animIndex = 0;
            attackTimer = 0;
            phase = 0;
        }
        break;
}

if (flashTimer &gt; 0)
{
    flashTimer--;
    
    with (objMegaman)
    {
        if (isHit || other.flashTimer &lt;= 0)
        {
            if (lockPoolExists(other.flashLock[playerID]))
            {
                other.flashLock[playerID] = lockPoolRelease(other.flashLock[playerID]);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// On Death
event_inherited();

with (objEnemyBullet) {
    if (parent == other.id)
        instance_destroy();
}

for (var i = 0; i &lt; global.playerCount; i++) {
    if (lockPoolExists(flashLock[i]))
        flashLock[i] = lockPoolRelease(flashLock[i]);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// On Hurt
event_inherited();

hasFlashed = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
