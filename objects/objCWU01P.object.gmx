<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprCWU01PPreview</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

healthpointsStart = 28;
healthpoints = healthpointsStart;
contactDamage = 4;

introType = 0;
customPose = true;
isDying = false;

blockCollision = false;
grav = 0;

image_speed = 0.125;

manualColors = true;
healthBarPrimaryColor[1] = global.nesPalette[paletteEnums.ORANGE+paletteEnums.BRIGHTNESS2];
healthBarSecondaryColor[1] = global.nesPalette[paletteEnums.MONOCHROME+paletteEnums.BRIGHTNESS3];

canHit = false;
canIce = false;
bubbleTimer = -1;//Not for our bubble, the breathing bubble.
inWater = -1;

bubble = noone;
bubbleExists = false;

introPhase = 0;

//These are intentional: They're divisions of the actual subpixels + some help Zieldak did in his own research.
speeds = makeArray(1.27734375,1.27734375,1.59765625,1.59765625,2.3984375,3.19921875,4);
spd = speeds[0];
col = 0;
colOffset = 0;
phase = 0;
dir = 0;
mDir = "up";
pDir = 0;
angle = 0;

attackTimer = 0;
deadTimer = 0;
imageIndex = 0;

initDoor = 0;
stepFwd = false;
opening = false;
closing = false;

canMove = false;
moveToPoint = false;
reset = false;

healthpointsPrev = healthpoints;

sprite_index = sprCWU01P;

// Music
music = "Mega_Man_1.nsf";
musicType = "VGM";
musicTrackNumber = 13;
musicVolume = 1;
musicLoop = true;
musicLoopSecondsStart = 6.661;
musicLoopSecondsEnd = 33.328;

tempYView = view_yview;


fireTimer = 0;
spawnSpot = -1;
image_speed = 0;

changeDirections = false;//@cc Does CWU change directions each time? Default is always counter clockwise.
showIntro = false;//@cc Does CWU show up before the start?

despawnRange = -1;
respawnRange = -1;

// Damage Table
var prevDV = specialDamageValues;
var prevDVT = specialDamageValuesTotal;

enemyDamageValue(objBusterShot,2);
enemyDamageValue(objBusterShotHalfCharged,2);
enemyDamageValue(objBusterShotCharged,4);
enemyDamageValue(objBusterShotHalfChargedProto,2);
enemyDamageValue(objBusterShotChargedProto,4);
enemyDamageValue(objNormalBusterShot, 2);

// MaGMML3
enemyDamageValue(objSparkChaser, 2);
enemyDamageValue(objLaserTrident, 6);
enemyDamageValue(objWaterShield, 0);
enemyDamageValue(objTornadoBlow, 0);
enemyDamageValue(objThunderBeam, 4);
enemyDamageValue(objBreakDash, 0);
enemyDamageValue(objMagneticShockwave, 0);
enemyDamageValue(objIceWall, 3);

// MaGMML2
enemyDamageValue(objHornetChaser, 6);
enemyDamageValue(objJewelSatellite, 2);
enemyDamageValue(objGrabBuster, 2);
enemyDamageValue(objTripleBlade, 6);
enemyDamageValue(objSlashClaw, 12);
enemyDamageValue(objWheelCutter, 6);
enemyDamageValue(objSakugarne, 20);
enemyDamageValue(objSuperArrow, 4);
enemyDamageValue(objWireAdapter, 2);

// MaGMML1
enemyDamageValue(objMetalBlade, 2);
enemyDamageValue(objGeminiLaser, 2);
enemyDamageValue(objSolarBlaze, 2);
enemyDamageValue(objTopSpin, 0);
enemyDamageValue(objThunderWool, 12);
enemyDamageValue(objPharaohShot, 2);
enemyDamageValue(objBlackHoleBomb, 2);
enemyDamageValue(objMagicCard, 6);

// MaG48HMML
enemyDamageValue(objFlameMixer, 2);
enemyDamageValue(objRainFlush, -20);
enemyDamageValue(objSparkShock, 4);
enemyDamageValue(objSearchSnake, 6);
enemyDamageValue(objTenguBlade, 12);
enemyDamageValue(objTenguDash, 12);
enemyDamageValue(objTenguDisk, 12);
enemyDamageValue(objSaltWater, 0);
enemyDamageValue(objConcreteShot, 2);
enemyDamageValue(objHomingSniper, 2);

// MaG24HMML
enemyDamageValue(objWaterWave, 0);
enemyDamageValue(objSuperArmBlockProjectile, 20);
enemyDamageValue(objSuperArmDebris, 20);
enemyDamageValue(objChillSpike, 2);
enemyDamageValue(objChillSpikeLanded, 20);

// Misc
enemyDamageValue(objPowerStone, 10);
enemyDamageValue(objPlantBarrier, 2);
enemyDamageValue(objBlockDropper, 20);
enemyDamageValue(objIceSlasher, 0);


reflectedDamage = 3;
if (reflectedDamage &gt; -1) 
enemyDamageValue(prtEnemyProjectile,reflectedDamage);

//Values above get carried into the bubble object, which actually takes damage instead.
bubbleDamageValues = specialDamageValues;
bubbleDamageValuesTotal = specialDamageValuesTotal;
specialDamageValues = prevDV;
specialDamageValuesTotal = prevDVT;
//Time Hands do 2 damage, oil slider without sliding 4, and with sliding 10. All other PU weapons are just 3.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!isFight)
{
    alarm[1] = 1;
}
else
{
    event_user(0);
    visible = true;
    alarm[0] = 126;
    phase = -2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>phase = -1;
fireTimer = 333; //222;
canMove = true;
image_xscale = -1;
if !(!changeDirections || col == 0 || col == 2 || col == 4 || col == 6)
{
    image_xscale = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

canHit = false;

if (entityCanStep())
{
    if (showIntro)
    {
        if (startIntro)
        {
            x = view_xview + view_wview + 48;
            calibrateDirection();
            canFillHealthBar = false;
            image_index = 0;
            startIntro = false;
            isIntro = true;
            introPhase = 0;
            initDoor = 1;
            opening = true;
            visible = true;
            attackTimer = 0;
            bubbleExists = false;
            canMove = false;
            dir = 1;
            mDir = 'up';
            
        }
        else if (isIntro)
        {
            switch (introPhase)
            {
                case 0:
                    canFillHealthBar = true;
                    attackTimer += 1;
                    if (attackTimer &gt;= 90)
                    {
                        event_user(1);
                    }
                    if (stepFwd == true) {stepFwd = false; attackTimer = 0; introPhase = 1;}
                    break;
                case 1:
                    if (x &gt;= xstart) {x -= 1.5;}
                    else if (x &lt; xstart) {closing = true; introPhase = 2; initDoor = 1;}
                    break;
                case 2:
                    event_user(1);
                    if (stepFwd == true) {stepFwd = false; introPhase = 0; isIntro = false;}
                    break;
            }
            
        }
    }
    else if (!isFight)
    {
        visible = false;
    }
    if (isFight)
    {
        /*//////////////////////////////////////////
        //Handle phases                           //
        //////////////////////////////////////////*/
        switch (phase)
        {
            case -2:
                exit;//Wait for the timer to be up.
            break;
            case -1://Realign ourselves with the stage.
                switch (spawnSpot)
                {
                    case 0:
                        if (y &lt; tempYView+80)
                        {
                            mDir = "down";
                            //spd = speeds[col];
                        }
                        else
                        {
                            phase = 0;
                            spawnSpot = -1;
                            image_xscale = -1;
                        }
                    break;
                    case 1:
                        if (x &lt; view_xview+48)
                        {
                            mDir = "right";
                        }
                        else
                        {
                            phase = 0;
                            spawnSpot = -1;
                            image_xscale = 1;
                        }
                    break;
                    case 2:
                        if (x &gt; (view_xview + view_wview - 48))
                        {
                            mDir = "left";
                        }
                        else
                        {
                            phase = 0;
                            spawnSpot = -1;
                            image_xscale = -1;
                        }
                    break;
                }
            if (bubbleExists || !insideView())
            {
                break;//Inherit to 0 until we have our bubble
            }
            case 0:
                imageIndex += 0.5;
                if (imageIndex &gt;= 4)
                {
                    if (!instance_exists(objCWU01PBubble))
                    {
                        //playSFX(sfxChillGloop);
                        bubble = instance_create(x,y,objCWU01PBubble);
                        bubble.parent = id;
                        bubble.sprite_index = sprCWU01PBubbleSpawn1;
                        bubbleExists = true;
                        phase = 1;
                        canMove = 1;
                        imageIndex = 0;
                        bubble.specialDamageValues = bubbleDamageValues;
                        bubble.specialDamageValuesTotal = bubbleDamageValuesTotal;
                    }
                }
                image_index = imageIndex;
                break;
            case 1:
                /*if (!instance_exists(target))
                {
                    if (!isDying)
                    {
                        spd = 0;
                        isDying = 1;
                    }
                }*/
                if (!bubbleExists)
                {
                    healthpoints -= 4;
                    if (healthpoints &lt;= 0)
                    {
                        event_user(EV_DEATH);
                    }
                    else
                    {
                        phase = 2;
                        canMove = 0;
                        attackTimer = 60;
                        iFrames = attackTimer;
                    }
                }
                break;
            case 2:
                /*//////////////////////////////////////////
                //Adjust spd according to remaining health//
                //Also set color                          //
                //////////////////////////////////////////*/
                fireTimer = 0;
                if (attackTimer == 60)
                {
                    var bubbleNumber = 7-(floor(healthpoints/4+0.75));
                    spd = speeds[bubbleNumber];
                    col = bubbleNumber;
                    event_user(0);
                    
                }
                attackTimer = -1; //-= 1;
                if (attackTimer &lt;= 0)
                {
                    moveToPoint = 1;
                    phase = -2;
                    
                    alarm[0] = 126;
                    reset = false;
                    colOffset = 0;
                    attackTimer = 0;
                }
            break;
        }
        
        /*//////////////////////////////////////////
        //Handle movement                         //
        //////////////////////////////////////////*/
        
        if (canMove == 1) 
        {
            attackTimer += 1;
            fireTimer = (fireTimer-1);
            if (fireTimer == -1)
            {
                fireTimer = 222;
            }
            
            switch (col)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    if (!changeDirections || col == 0 || col == 2 || col == 4 || col == 6)
                    {
                        switch (mDir)//Clockwise.
                        {
                        case 'default':
                            xspeed = 0;
                            yspeed = -spd;
                            if (y &lt; (tempYView + 64))
                            {
                                mDir = 'right';
                                y += spd;
                            }
                            break;
                        
                        case 'up':
                            xspeed = 0;
                            yspeed = -spd;
                            if (y &lt; (tempYView + 64))
                            {
                                mDir = 'right';
                                y += spd;
                            }
                            break;
                        case 'left':
                            image_xscale = -1;
                            xspeed = -spd;
                            yspeed = 0;
                            if (x &lt; (view_xview + 48))
                            {
                                mDir = 'up';
                                x += spd;
                            }
                            break;
                        case 'down':
                            xspeed = 0;
                            yspeed = spd;
                            if (y &gt; (tempYView + view_hview - 80))
                            {
                                mDir = 'left';
                                y -= spd;
                            }
                            break;
                        case 'right':
                            image_xscale = 1;
                            xspeed = spd;
                            yspeed = 0;
                            if (x &gt; (view_xview + view_wview - 48))
                            {
                                mDir = 'down';
                                x -= spd;
                            }
                            break;
                        }
                    }
                    else
                    {
                        switch (mDir)//Counter Clockwise
                        {
                        case 'default':
                            xspeed = 0;
                            yspeed = -spd;
                            if (y &lt; (tempYView + 64))
                            {
                                mDir = 'left';
                                y += spd;
                            }
                            break;
                        case 'up':
                            xspeed = 0;
                            yspeed = -spd;
                            if (y &lt; (tempYView + 64))
                            {
                                mDir = 'left';
                                y += spd;
                            }
                            break;
                        case 'left':
                            image_xscale = -1;
                            xspeed = -spd;
                            yspeed = 0;
                            if (x &lt; (view_xview + 48))
                            {
                                mDir = 'down';
                                x += spd;
                            }
                            break;
                        case 'down':
                            xspeed = 0;
                            yspeed = spd;
                            if (y &gt; (tempYView + view_hview - 64))
                            {
                                mDir = 'right';
                                y -= spd;
                            }
                            break;
                        case 'right':
                            image_xscale = 1;
                            xspeed = spd;
                            yspeed = 0;
                            if (x &gt; (view_xview + view_wview - 48))
                            {
                                mDir = 'up';
                                x -= spd;
                            }
                            break;
                        }
                    }
                    if ((fireTimer == 60) || (fireTimer == 90) || (fireTimer == 120))
                    {
                        if (instance_number(objCWU01PShot) &lt; 3)//2 instances at a time.
                        {
                            playSFX(sfxEnemyShootClassic);
                            instance_create(x,y,objCWU01PShot);
                        }
                    }
                break;
            }
        }
        else
        {
            xspeed = 0;
            yspeed = 0;
        }
        
        /*//////////////////////////////////////////
        //Adjust bubble position and stuff        //
        //////////////////////////////////////////*/
        if (instance_exists(bubble))
        {
            bubbleExists = true;
            with (bubble)
            {
                x = other.x;
                y = other.y;
                image_xscale = other.image_xscale;
            }
        }
        else
        {
            bubbleExists = false;
        }
    }
    else if (isDying)
    {
        if (!deadTimer)
        {
            with objBossBarrier { event_user(0); }
        }
        
        deadTimer++; //Do this here so we don't crash later

        // flickering
        if (deadTimer mod 2 == 0)
        {
            visible = !visible;
        }
            
        if (deadTimer mod (10 - floor(deadTimer / 30)) == 0)
        {
            var xcenter = bbox_left + abs(bbox_left - bbox_right) / 2;
            var ycenter = bbox_top + abs(bbox_top - bbox_bottom) / 2;
            playSFX(sfxMM9Explosion);
            
            var inst = instance_create(xcenter + irandom_range(-(sprite_width / 2),
                (sprite_width / 2)),
                ycenter + irandom_range(-(sprite_height / 2) + 16,
                (sprite_height / 2) - 16), objBigExplosion);
            with (inst)
            {
                image_speed = 1 / 3;
                sprite_index = sprBigExplosion;
            }
        }
        if (deadTimer &gt;= 120)
        {
            event_user(EV_DEATH);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!showIntro)
{
    introType = 2;
    
    
    alarm[1] = 1;
}
event_inherited();

if (global.quadHeight == 240)//Auto-set for block collision to the correct quad type if incorrect.
{
    tempYView = view_yview-8;
}
else
{
    tempYView = view_yview;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (objCWU01PShot)
{
    instance_create(bboxGetXCenter(),bboxGetYCenter(),objExplosion);
    instance_destroy();
}
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*if instance_exists(objBossDoor) Not used, but can be used to have CWU navigate a door when first entering (Does not work on subsequent entrances).
{
    with instance_nearest(xstart,ystart,objBossDoor)
    {
        if (other.initDoor == 1)
        {
            opening = other.opening;
            closing = other.closing;
            other.initDoor = 0;
            other.stepFwd = false;
        }
        if ((opening) and (doorHeight == 0)) || ((closing) and (doorHeight == height))
        {
            other.stepFwd = true;
            if (closing)
            {
                isTile = false;
                sprite_index = sprCWU01PDoor;
            }
        }
    }
}
else
{
    other.stepFwd = true;
}*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Teleport to new hole.
var locationsY = makeArray(tempYView-sprite_get_height(sprCWU01PBubble),ystart,ystart);
var locationsX = makeArray(view_xview+view_wview/2,view_xview-sprite_get_width(sprCWU01PBubble),view_xview+view_wview+sprite_get_width(sprCWU01PBubble));
var loc = choose(0,1,2);
x = locationsX[loc];
y = locationsY[loc];
spawnSpot = loc;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var palettes = makeArray(39,34,42,36,38,23,21);

switch (fireTimer)
{
    case 70: colOffset = 1; break;
    case 65: colOffset = 2; break;
    case 60: colOffset = 0; break;
    case 100: colOffset = 1; break;
    case 95: colOffset = 2; break;
    case 90: colOffset = 0; break;
    case 130: colOffset = 1; break;
    case 125: colOffset = 2; break;
    case 120: colOffset = 0; break;
}
var palette = palettes[col];
var op = palette;

if (colOffset == 1)
{
    palette += 16;//Go down a bright.
}

//Now to make up for how the nes palette here is a pain with maths.
//TODO 2.0: Undo this, we reindexed the palettes lol.
if (palette &gt; 12)
{
    palette -= 3;//Skip 3 black on this row.
}
if (palette &gt; 25)
{
    palette -= 3;//Skip 3 black on this row.
}
if (palette &gt; 39)
{
    palette -= 3;//Skip 2 black on this row.
}
if (op != palette)
{
    if (op &gt; 12)
    {
        op -= 3;//Skip 3 black on this row.
    }
    if (op &gt;  25)
    {
        op -= 3;//Skip 3 black on this row.
    }
    if (op &gt; 39)
    {
        op -= 3;//Skip 2 black on this row.
    }
}
if (colOffset == 2)
{
    palette = 40;//Turn to white.
}
healthBarPrimaryColor[1] = global.nesPalette[global.nesOldIndexToNew[op]];
healthBarSecondaryColor[1] = global.nesPalette[global.nesOldIndexToNew[40]];
//We can ignore the last row.
if ((phase == 0) || (phase == 1 and bubbleExists))
{
    if (healthpoints &gt; healthpointsStart)
    {
        healthpoints = healthpointsStart;
    }
    
}
if (!dead &amp;&amp; drawBoss) // actually draw itself
{

    if ((iFrames mod 4) &lt; 2 || !iFrames)
    {
        draw_sprite_ext(sprCWU01P,0,x,y,image_xscale,image_yscale,image_angle,c_white,image_alpha);//draw_sprite_ext(sprCWU01PEye,col + (colOffset * 7), x, y, image_xscale,image_yscale,image_angle,image_blend,image_alpha);
        draw_sprite_ext(sprCWU01P,1,x,y,image_xscale,image_yscale,image_angle,global.nesPalette[global.nesOldIndexToNew[palette]],image_alpha);//draw_sprite_ext(sprCWU01PEye,col + (colOffset * 7), x, y, image_xscale,image_yscale,image_angle,image_blend,image_alpha);
    }
    else // Hitspark
    {
        draw_sprite_ext(sprHitspark, 0, spriteGetXCenter(), spriteGetYCenter(), 1, 1, 0, c_white, 1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
