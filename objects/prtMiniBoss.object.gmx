<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

itemDrop = -1;

doesIntro = true;
lockTransition = true;


killOverride = false;
killed = false;

despawnRange = -1;


introSprite = sprHotDogTeleport;
introTimer = 288 + 15; // 288 is the height above, 15 is the extra frames for teleporting in.
_init = 1;
xplX = -100;
xplY = -100;

canIce = false; // Shouldn't be able to freeze minibosses

drawHealthBar = false;
healthBarPrimaryColor[1] = $28;
healthBarSecondaryColor[1] = $30;
healthBarBackgroundColor = c_black;
healthBarColorSkip = 1;
manualColors = false;

playBossMusic = false;
killBossMusic = true;

/* BOSS SETTINGS ! - this is mostly to help setup boss gallery and therefore needs
more robust changes to make it work properly in future devkits
ideally I think it'd be nice to have this as a 8bit remix of MM8's mid-boss theme, as its one
of the few canonical expamples in teh series.*/
music = "Mega_Man_2.nsf";
musicType = "VGM";
musicTrackNumber = 17;
musicVolume = 0.8;
musicLoop = true;
musicLoopSecondsStart = 8.825;
musicLoopSecondsEnd = 61.575;

// Music storage for restarting it after death
musicStore = "";
musicTypeStore = "";
musicLoopStartStore = 0;
musicLoopEndStore = 1;
musicLoopStore = 0;
musicVolumeStore = 0.8;
musicTrackNumberStore = 0;

musicChanged = false;

rescursiveExplosion = true; // Use this to set whether or not an explosion chain follows death.
doExplosion = true; // Hacky fix for Tricastle

//recursive explosion variables
deadDelay = 0; //@cc if set, delay explosions until this has passed.
deadFrame = -1; //@cc if set, display this frame when exploding
deadFrameMax = -1; // @cc if set, animation to this frame
deadFrameRecur = 5;
deadTimerRecur = 5; //@cc how often explosions occur
deadTimerMax = 60; //@cc how long the boss explodes for
explosionSFX = sfxExplosion; //@cc explosion sound
explosionSprite = sprBigExplosion; //@cc explosion graphics.

//set the below variable to sprMegaman to create the player explosion upon death, which uses the above variables to grab graphics.
finalExplosionSprite = noone; //cc entity destruction sprite. 
finalExplosionSFX = noone;// if set, use specific explosion sample for its final explosion. this defaults to the player death if above is set to sprMegaman.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (killed)
{
    healthpoints = 0;
    beenOutsideView = false;
}

event_inherited();
if (killed)
{
    healthpoints = 0;
    beenOutsideView = false;
}

if (introTimer &gt; 0 &amp;&amp; doesIntro)
{
    if (insideView())
    {
        if (introTimer &gt; 10)
        {
            introTimer -= 8;
        }
        else
        {
            introTimer -= 1;
        }
    }
}

if (dead)
{
    _init = 1;
}
else if (_init == 1)
{
    _init = 0;
    if (lockTransition)
    {
        global.lockTransition = true;
    }
}
if (!global.frozen &amp;&amp; dead &amp;&amp; !instance_exists(objSectionSwitcher) &amp;&amp; killed)
{
    xspeed = 0;
    yspeed = 0;
    
    if (rescursiveExplosion &amp;&amp; respawn)
    {
        x = xplX;
        y = xplY;
        if (deadTimer == 0)
        {
            if (deadFrame != -1)
                image_index = deadFrame;
        }
        deadTimer += 1;
        
        // flickering
        if (deadTimer &gt; deadDelay &amp;&amp; deadTimer mod 2 == 0)
        {
            visible = !visible;
        }
        
        if (deadTimer &gt; deadDelay &amp;&amp; floor(deadTimer / deadTimerRecur) * deadTimerRecur == deadTimer)
        {
            var xcenter = bbox_left + abs(bbox_left - bbox_right) / 2;
            var ycenter = bbox_top + abs(bbox_top - bbox_bottom) / 2;
            playSFX(explosionSFX);
            // randomize();
            inst = instance_create(xcenter + irandom_range(-(sprite_width / 2),
                (sprite_width / 2)),
                ycenter + irandom_range(-(sprite_height / 2) - 16,
                (sprite_height / 2) + 16), objBigExplosion);
            with (inst)
            {
                image_speed = 1 / 3;
                sprite_index = other.explosionSprite;
            }
            
        }
        
        if (floor(deadTimer / deadFrameRecur) * deadFrameRecur == deadTimer)
        {
            if (deadFrameMax != -1)
            {
                if (image_index &lt; deadFrameMax)
                {
                    image_index ++;
                }    
            }
        }
        
        if (deadTimer &gt;= deadTimerMax)
        {
            if (lockTransition)
            {
                var canUnlock = true;
                var i = 0;
                with (prtMiniBoss)
                {
                    if (!dead &amp;&amp; lockTransition)
                    {
                        canUnlock = false;
                        break;
                    }
                }
                if (canUnlock)
                {
                    global.lockTransition = false;
                }
            }
            
            if (finalExplosionSprite != sprMegaman)
            {
                //create centered explosion.
                inst = instance_create(spriteGetXCenter(), spriteGetYCenter(),
                        objBigExplosion);
                        
                if (finalExplosionSFX != noone)
                {
                    playSFX(finalExplosionSFX);
                }
                with (inst)
                {
                    image_speed = 1 / 3;
                    if (other.finalExplosionSprite != noone)
                    {
                         sprite_index = other.finalExplosionSprite;
                    }
                    else
                    {
                        sprite_index = other.explosionSprite;
                    }
                }
            }
            else
            {
                var ex = getGenericSFX(SFX_BOSSDIE);
                if (finalExplosionSFX != noone)
                {
                    ex = finalExplosionSFX;
                }
                playerExplosion(explosionSprite,1.5,-1,ex);
            }
            instance_destroy();
        }
    }
    else
    {
        x = xplX;
        y = xplY;
        deadTimer += 1;
        if (deadTimer &gt;= 2 || !respawn)
        {
            var xcenter = bbox_left + abs(bbox_left - bbox_right) / 2;
            var ycenter = bbox_top + abs(bbox_top - bbox_bottom) / 2;
            if (doExplosion) // Read: If not Tricastle
            {
                if (finalExplosionSprite != sprMegaman)
                {
                    playSFX(explosionSFX);
                    
                    inst = instance_create(spriteGetXCenter(), spriteGetYCenter(),
                        objBigExplosion);
                    with (inst)
                    {
                        image_speed = 1 / 3;
                        if (other.finalExplosionSprite != noone)
                        {
                             sprite_index = other.finalExplosionSprite;
                        }
                        else
                        {
                            sprite_index = other.explosionSprite;
                        }
                    }
                }
                else
                {
                    var ex = getGenericSFX(SFX_BOSSDIE);
                    if (finalExplosionSFX != noone)
                        ex = finalExplosionSFX;
                    playerExplosion(explosionSprite,1.5,-1,ex);
                }
            }
            if (lockTransition)
            {
                var canUnlock = true;
                var i = 0;
                with (prtMiniBoss)
                {
                    if (!dead &amp;&amp; lockTransition)
                    {
                        canUnlock = false;
                        break;
                    }
                }
                if (canUnlock)
                {
                    global.lockTransition = false;
                }
            }

            instance_destroy();
        }
    }
} /* else if (!insideView() &amp;&amp; deadTimer &gt; 0 &amp;&amp; !rescursiveExplosion)
{
    instance_destroy();
}*/
else if (!killed)
{
    deadTimer = 0;
    visible = true;
    if (!musicChanged &amp;&amp; playBossMusic &amp;&amp; !killBossMusic)
    {
        with (prtMiniBoss)
        {
            musicStore = global.levelSong;
            musicTypeStore = global.levelSongType;
            musicLoopStartStore = global.levelLoopStart;
            musicLoopEndStore = global.levelLoopEnd;
            musicLoopStore = global.levelLoop;
            musicVolumeStore = global.levelVolume;
            musicTrackNumberStore = global.levelTrackNumber;
            musicChanged = true;
        }
        stopMusic();
        playMusic(music, musicType, musicTrackNumber, musicLoopSecondsStart, musicLoopSecondsEnd, musicLoop, musicVolume);
    }
}

// Here's some, as Spin Attaxx called it, "code hoarding"
//" Die" (doesn't actually destroy the enemy though)
/* if (healthpoints &lt;= 0)
{
    beenOutsideView = false;
    dead = true; // Enemies don't actually destroy themselves, they become invisible and all collision is neglected
    xspeed = 0;
    yspeed = 0;
}

// Respawning
if (respawn)
{
    if (beenOutsideView)
    {
        if (insideView())
        {
            visible = true;
            dead = false;
            healthpoints = healthpointsStart;
            beenOutsideView = false;
            preventDeath = false;
        }
    }
}
else if (dead) and !respawn
{
    instance_destroy(); // If we can't respawn, there's no point to still be able to execute any code. Destroying the instance saves memory and processing power
}

if (!insideView() &amp;&amp; despawnRange != -1)
{
    beenOutsideView = true;
    
    x = xstart;
    y = ystart;
    healthpoints = 0;
    dead = true;
    visible = false;
    xspeed = 0;
    yspeed = 0;
    preventDeath = true;
}*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
killed = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
xplX = x;
xplY = y;
killed = true;
if (playBossMusic)
{
    var switchTheme = true;
    with (prtMiniBoss)
    {
        if (playBossMusic &amp;&amp; !killed)
        {
            switchTheme = false;
        }
    }
    
    if (!switchTheme)
    {
        playMusic(musicStore, musicTypeStore, musicTrackNumberStore, musicLoopStartStore, musicLoopEndStore, musicLoopStore, musicVolumeStore);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!spawned)
    exit;
    
//attempt at a fix to prevent mini bosses from appearing at their original position when the screen fades out
if (dead &amp;&amp; objGlobalControl.fadetimer &gt; 0) 
    exit;
    
if (introTimer &gt; 0 &amp;&amp; doesIntro)
{
    draw_sprite_ext(introSprite, 2 - (min(2, min(introTimer, 15) / 5)), x,
        y - max(introTimer - 10, 0), image_xscale, image_yscale, 0, c_white, 1);
}
else
{
    if ((ceil(iFrames / 2) mod 4) || !iFrames)
    {
        if ((ceil(iFrames / 2) mod 2) || (iceTimer &gt; 0))
        {
            var flashcol = c_white;
            if (iceTimer &gt; 0)
            {
                flashcol = make_color_rgb(0, 120, 255);
            }
            
            hitFlashEffect(true,flashcol);
            drawSelf();
            hitFlashEffect(false);
            
            if (iceTimer &gt; 0)
            {
                draw_set_blend_mode(bm_add);
                drawSelf();
                draw_set_blend_mode(bm_normal);
            }
        }
        else
        {
            if (useShader)
            {
                shaderSetColorreplace(replaceColor[0],newColor[0],replaceColor[1],newColor[1],replaceColor[2],newColor[2],replaceColor[3],newColor[3]);
                drawSelf();
                shader_reset();
            }
            else
            {
                drawSelf();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
