<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMelodyResponseButton</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

isSolid = 1;

canHit = false;

num = -1;
pressed = false;
doIt = 0;

blockCollision = 0;
grav = 0;
bubbleTimer = -1;

respawnRange = -1;
despawnRange = -1;

image_index = 0;
image_speed = 0;



mySFX[0] = sfxMelodyResponseButton_A;
mySFX[1] = sfxMelodyResponseButton_B;
mySFX[2] = sfxMelodyResponseButton_C;
mySFX[3] = sfxMelodyResponseButton_D;
mySFX[4] = sfxMelodyResponseButton_E;
mySFX[5] = sfxMelodyResponseButton_F;



// entity specific variables
animationTimer = 0;
attackTimer = 0;
hasInit = false;
storageObjID = noone;

currentRotation = 0;
buttonNoPressed = 0;
buttonAmount = -1;
buttonPuzzle = -1;
randomList[0] = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>reset button state</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (object_index)
{
    hasInit = false;
    
    // pressed = false;
    buttonNoPressed = 0;
    currentRotation = 0;
    doIt = 0;
    if (attackTimer &gt; 0)
        alarm[1] = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>shunt mega man off button if needed</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (collision_rectangle(x, y, x + 15, y + 15, objMegaman, false, false))
{
    if (other.sprite_index == sprMelodyResponseButton &amp;&amp; gravDir == 1
        || (other.sprite_index == sprMelodyResponseButtonDown &amp;&amp; gravDir == -1))
    {
        y += -8;
    }
    if (other.sprite_index == sprMelodyResponseButton &amp;&amp; gravDir == -1
        || (other.sprite_index == sprMelodyResponseButtonDown &amp;&amp; gravDir == 1))
    {
        y += +8;
    }
    if (other.sprite_index == sprMelodyResponseButtonLeft)
    {
        x += +8;
    }
    if (sprite_index == sprMelodyResponseButtonRight)
    {
        x += -8;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (entityCanStep())
{
    // give each button in existance its own number.
    var storeNum = 0;
    
    with (objMelodyResponseButtonUp)
    {
        if (num == -1)
        {
            num = storeNum;
            storeNum++;
            buttonAmount = instance_number(objMelodyResponseButtonUp);
        }
    }
    
    // the first button in existance stores all variables needed to complete the puzzle.
    if (num == 0)
    {
        if (instance_exists(objMelodyResponseCannon))
        {
            with (instance_nearest(x, y, objMelodyResponseCannon))
            {
                if (allButtons)
                {
                    var useAllButtons = true;
                    buttonsToPress = other.buttonAmount;
                }
                else
                {
                    var useAllButtons = false;
                }
                other.buttonPuzzle = buttonsToPress;
            }
        }
        else
            with (instance_nearest(x, y, objMelodyResponseDoor)) // if not mini boss exists, grab variables from door.
            {
                if (allButtons)
                {
                    var useAllButtons = true;
                    buttonsToPress = other.buttonAmount;
                }
                else
                {
                    var useAllButtons = false;
                }
                other.buttonPuzzle = buttonsToPress;
            }
        
        var store0ID = id;
        if (!hasInit) // initialize the puzzle
        {
            for (var e = 0; e &lt; buttonPuzzle; e++) // setup list of variables
            {
                if (!useAllButtons)
                {
                    randomList[e] = irandom(buttonAmount - 1);
                }
                else
                {
                    randomList[e] = e;
                }
            }
            
            var i, j, k; // then randomise list
            for (i = 0; i &lt; buttonPuzzle; i++)
            {
                j = irandom_range(i, buttonPuzzle - 1);
                if (i != j)
                {
                    k = randomList[i];
                    randomList[i] = randomList[j];
                    randomList[j] = k;
                }
            }
            hasInit = true;
        }
        
        if (instance_exists(objMelodyResponseCannon) || instance_exists(objMelodyResponseDoor)) // the buttons are only active whilst either a door or response cannon is in existance
        {
            attackTimer++;
        }
        
        if (attackTimer == 35 &amp;&amp; currentRotation &lt; buttonPuzzle) // flash buttons in sequence
        {
            var getListNumber = randomList[currentRotation];
            attackTimer = 0;
            //playSFX(sfxGrabBuster);
            with (objMelodyResponseButtonUp)
            {
                if (num == getListNumber)
                {
                    animationTimer = 25;
                    pressed = false;
                    alarm[1] = 1;
                    playSFXPitched(mySFX[num mod 6],1-(floor(num/5)*0.2));
                }
            }
            currentRotation++;
        }
        
        if (currentRotation == buttonPuzzle) // sequence complete, puzzle can now be attempted
        {
            with (objMelodyResponseButtonUp)
            {
                storageObjID = store0ID;
                hasInit = true;
            }
        }
    }
    
    // setup animation for buttons here
    if (animationTimer &gt; 0)
    {
        image_index = (animationTimer / 4) mod 3;
        animationTimer--;
    }
    else
    {
        if (!pressed)
        {
            image_index = 0;
        }
    }
    
    if (image_index == 3) // setup collision masks depending on sprite state.
    {
        switch (sprite_index)
        {
            case sprMelodyResponseButton:
                mask_index = mskMelodyButton;
                break;
            case sprMelodyResponseButtonLeft:
                mask_index = mskMelodyButton2;
                break;
            case sprMelodyResponseButtonRight:
                mask_index = mskMelodyButton3;
                break;
            case sprMelodyResponseButtonDown:
                mask_index = mskMelodyButton4;
                break;
        }
        
        if (!collision_rectangle(x, y, x + 16, y + 16, objMegaman, false, false)) // if colliding with mega man, the buttons do not reset
        {
            pressed = false;
        }
    }
    else
    {
        mask_index = sprite_index;
    }
    
    if (instance_exists(storageObjID) &amp;&amp; (instance_exists(objMelodyResponseCannon) || instance_exists(objMelodyResponseDoor))) // check for existance of various objects or else *CRASH*
    {
        // whilst all these are true, buttons can be pressed
        if (instance_exists(target) &amp;&amp; storageObjID.currentRotation &gt;= buttonPuzzle &amp;&amp; storageObjID.attackTimer &gt;= 36 &amp;&amp; animationTimer == 0 &amp;&amp; image_index == 0)
        {
            doIt = 0;
            with (objMegaman)
            {
                with (other) // depending on the sprite, determines what side the button can be pressed
                {
                    if ((sprite_index == sprMelodyResponseButton &amp;&amp; other.gravDir == 1)
                        || (sprite_index == sprMelodyResponseButtonDown &amp;&amp; other.gravDir == -1))
                    {
                        if (place_meeting(x, y - 1 * other.gravDir, other.id) &amp;&amp; other.ground)
                        {
                            doIt = 1;
                        }
                    }
                    if ((sprite_index == sprMelodyResponseButtonDown &amp;&amp; other.gravDir == 1)
                        || (sprite_index == sprMelodyResponseButton &amp;&amp; other.gravDir == -1))
                    {
                        if (place_meeting(x, y + 2 * other.gravDir, other.id)) // &amp;&amp; !other.target.ground
                        {
                            doIt = 1;
                        }
                    }
                    if (sprite_index == sprMelodyResponseButtonRight)
                    {
                        if (place_meeting(x - 1, y, other.id) &amp;&amp; (other.xspeed &gt; 0
                            || other.isSlide
                            || global.keyRight[other.playerID]))
                        {
                            doIt = 1;
                        }
                    }
                    if (sprite_index == sprMelodyResponseButtonLeft)
                    {
                        if (place_meeting(x + 1, y, other.id) &amp;&amp; (other.xspeed &lt; 0
                            || other.isSlide
                            || global.keyLeft[other.playerID]))
                        {
                            doIt = 1;
                        }
                    }
                }
            }
            if (doIt)
            {
                image_index = 3;
                var getNum = num;
                with (storageObjID)
                {
                    if (getNum != randomList[buttonNoPressed]) // if button pressed is wrong, play error sound and activate all melody response cannons
                    {
                        playSFX(sfxError);
                        attackTimer = -35;
                        alarm[2] = 1;
                        with (objMelodyResponseCannon)
                        {
                            attackTimer = 64;
                        }
                    }
                    else // otherwise add to variable stored
                    {
                        buttonNoPressed++;
                        if (buttonNoPressed == buttonPuzzle) // if entire sequence is entered, then defeat one melody response cannon
                        {
                            if (!instance_exists(objMelodyResponseCannon))
                            {
                                with (objMelodyResponseDoor) // or defeat the door if no cannons exist
                                {
                                    animTimer = 1;
                                    playSFX(sfxMenuSelect);
                                }
                            }
                            var mrc = instance_nearest(x, y, objMelodyResponseCannon);
                            with (mrc)
                            {
                                event_user(EV_DEATH);
                            }
                            alarm[2] = 1;
                            with (storageObjID)
                            {
                                attackTimer = -100;
                            }
                        }
                    }
                }
                if (!pressed) // one off variable to play button press sound
                {
                    playSFX(sfxCrashBombArm);
                    playSFXPitched(mySFX[num mod 6],1-(floor(num/5)*0.2));
                    pressed = true;
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>other.guardCancel = 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// debug
/*
draw_set_colour(c_white);
draw_text(x,y,num);
draw_text(x+8,y,currentRotation);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
