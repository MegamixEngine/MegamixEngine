<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMM9SpinningPlatform</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtRailPlatform</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Players who land on this platform will stick to it, moving up and down as it rotates. Depending on their position, pressing JUMP will make them jump up or fall down.
/// By default, this platform moves horizontally along a track, but it can be made stationary with creation code (mySpeed = 0).
/// Use horizontal rails and bumpers (Gimmicks &gt; General &gt; Invisible Rails) to build the track. Rails are required even if the platform is stationary.
/// If desired, place tiles (e.g. Tilesets &gt; MM9 &gt; tstTornadoman) onto the rail objects to show players where the track is.
/// Can be difficult to use in a non-frustrating way, and utilizes unique player sprites that most sprite artists find challenging to draw.

event_inherited();
canHit = false;

image_speed = 0.1;

respawnRange = -1;
despawnRange = -1;

xOffset = 16;
noFlicker = true;

isSolid = 2;
blockCollision = 0;
grav = 0;

mySpeed = 1;

// Enemy-specific code
spinRate = (1 / 3);
spinMod = 10;

for (i = 0; i &lt; global.playerCount; i += 1)
{
    spinTimer[i] = 0; 
    attached[i] = false;
    attachX[i] = x;
    offset[i] = 0;
    animOffset[i] = 0;
    shootLock[i] = false;
}

currX = x;
currY = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// Handle rotation animation
with (objMegaman)
{
    with (other)
    {
        if (attached[other.playerID])
        {
            other.x = x + attachX[other.playerID];
            other.y = y - 16 + (40 * offset[other.playerID]);
            other.image_yscale = 1;
            
            sprx = (animOffset[other.playerID] * 3);
            spry = 13;
            
            with (other)
            {
                playerHandleSprites("Magnet");
            }
        }
    }
}

// Stop movement if out of range
if (instance_exists(objMegaman))
{
    if (!insideSection(x, y))
    {
        x -= xspeed;
        y -= yspeed;
        x = currX;
        y = currY;
    }
    else
    {
        currX = x;
        currY = y;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (!global.frozen &amp;&amp; !dead)
{
    // Check for drop rails
    if (instance_exists(lastRail))
    {
        if (lastRail.drop)
        {
            image_speed = 0;
        }
        else
        {
            image_speed = 0.1;
        }
    }
    else
    {
        image_speed = 0.1;
    }
    
    // Rotate this absolute madman if they're touching the platform
    for (var i = 0; i &lt; global.playerCount; i ++)
    {
        with (instance_find(objMegaman, i))
        {
            with (other)
            {
                // Check if the player is touching the platform or is already attached
                if ((place_meeting(x, y - other.gravDir * 2, other) &amp;&amp; !place_meeting(x, y, other) &amp;&amp; other.ground)
                    || attached[other.playerID])
                {
                    // If they're not attached, start ROTATING
                    if (!attached[other.playerID])
                    {
                        attached[other.playerID] = true;
                        with (other)
                            other.shootLock[playerID] = lockPoolLock(localPlayerLock[PL_LOCK_SHOOT]);
                        attachX[other.playerID] = other.x - x; // set x rotation origin
                        
                        spinTimer[other.playerID] = 0; // reset timer
                        
                        // based on where they land on the platform, set the proper Stuff
                        if (other.y &gt; y + 8)
                        {
                            offset[other.playerID] = 1;
                            animOffset[other.playerID] = 0;
                            playerDir[other.playerID] = -1;
                        }
                        else
                        {
                            offset[other.playerID] = 0;
                            animOffset[other.playerID] = 0;
                            playerDir[other.playerID] = 1;
                        }
                    } // Actual rotating code
                    else if (attached[other.playerID])
                    {
                        // Update position + variables
                        
                        // Rotate UNLESS the platform is over a drop rail
                        if (image_speed &gt; 0)
                        {
                            spinTimer[other.playerID] += 1;
                            
                            if (spinTimer[other.playerID] mod spinMod == 0)
                            {
                                offset[other.playerID] += spinRate * playerDir[other.playerID];
                                animOffset[other.playerID] += spinRate;
                            }
                        }
                        
                        // handle playerDirection spinning when going under the platform etc
                        if (offset[other.playerID] &gt;= 1)
                        {
                            offset[other.playerID] = 1;
                            animOffset[other.playerID] = 1;
                            playerDir[other.playerID] = -1;
                        }
                        if (offset[other.playerID] &lt;= 0)
                        {
                            offset[other.playerID] = 0;
                            animOffset[other.playerID] = 0;
                            playerDir[other.playerID] = 1;
                        }
                        
                        // handle depth of player
                        depth = other.depth - playerDir[other.playerID];
                        
                        // Jumping off the platform
                        if (global.keyJumpPressed[other.playerID])
                        {
                            if (offset[other.playerID] &gt; 0.5)
                            {
                                other.yspeed = other.jumpSpeed;
                                other.canMinJump = true;
                            }
                            else
                            {
                                other.yspeed = -other.jumpSpeed;
                                other.canMinJump = true;
                            }
                            attached[other.playerID] = false;
                            
                            // It was easier to just flip the players sprites temporarily for this
                            other.image_yscale = other.gravDir;
                            shootLock[other.playerID] = lockPoolRelease(shootLock[other.playerID]);
                        }
                        
                        // no land sound pls
                        if (instance_exists(target))
                            target.playLandSound = 0;
                    }
                }
                else
                {
                    // This replicates the flicker effect seen in MM9
                    depth *= -1;
                    if (depth == 0)
                        depth = 1;
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
