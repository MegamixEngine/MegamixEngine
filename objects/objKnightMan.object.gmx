<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprKnightMan</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>sprKnightMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

healthIndex = 1;

healthpointsStart = 28;
healthpoints = healthpointsStart;
contactDamage = 4;

introType = 0;
customPose = true;
ground = false;
hasTriggeredFall = false;

phase = 0;
attackTimer = 0;
jumpX = 0;
jumpY = 0;
jumpSpeed = -5.8;
walkX = 0;
startXspeed = 0;
walkFrame = 0;

imgIndex = 0;

// @cc - Sets Knight Man's gravity
myGravity = 0.185;
// @cc - Sets how close Knight Man must be to do targeted jumps
targetJumpRange = 128;
// @cc - Sets Knight Crusher damage
maceDamage = 5;
// @cc - Sets Knight Crusher sprite
maceSprite = sprKnightProjectile;
// @cc - If false, Knight Man's shield will not work
hasShield = true;
// @cc - Sets shield coordinates (measured from x/y * image_xscale/yscale)
shieldX1 = 10;
shieldY1 = -18;
shieldX2 = 17;
shieldY2 = 16;
// @cc - Draws shield hitbox (FOR DEBUGGING PURPOSES ONLY)
debugGuard = false;

// Health Bar
healthBarPrimaryColor[1] = $12;
healthBarSecondaryColor[1] = $20;

// Music
music = "Mega_Man_6.nsf";
musicType = "VGM";
musicTrackNumber = 12;

// Damage Table
enemyDamageValue(objBusterShot, 1);
enemyDamageValue(objBusterShotHalfCharged, 1);
enemyDamageValue(objBusterShotCharged, 3);
enemyDamageValue(objBusterShotHalfChargedProto, 1);
enemyDamageValue(objBusterShotChargedProto, 3);

// MaGMML3
enemyDamageValue(objSparkChaser, 1);
enemyDamageValue(objLaserTrident, 4);
enemyDamageValue(objWaterShield, 1);
enemyDamageValue(objTornadoBlow, 1);
enemyDamageValue(objThunderBeam, 0);
enemyDamageValue(objBreakDash, 2);
enemyDamageValue(objMagneticShockwave, 1);
enemyDamageValue(objIceWall, 0);

reflectedDamage = -1;
if (reflectedDamage &gt; -1) 
    enemyDamageValue(prtEnemyProjectile,reflectedDamage);

// MaGMML2
enemyDamageValue(objHornetChaser, 1);
enemyDamageValue(objJewelSatellite, 0);
enemyDamageValue(objGrabBuster, 0);
enemyDamageValue(objTripleBlade, 1);
enemyDamageValue(objSlashClaw, 2);
enemyDamageValue(objWheelCutter, 4);
enemyDamageValue(objSakugarne, 1);
enemyDamageValue(objSuperArrow, 1);
enemyDamageValue(objWireAdapter, 1);

// MaGMML1
enemyDamageValue(objMetalBlade, 0);
enemyDamageValue(objGeminiLaser, 0);
enemyDamageValue(objSolarBlaze, 1);
enemyDamageValue(objTopSpin, 1);
enemyDamageValue(objThunderWool, 4);
enemyDamageValue(objPharaohShot, 1);
enemyDamageValue(objBlackHoleBomb, 1);
enemyDamageValue(objMagicCard, 2);

// MaG48HMML
enemyDamageValue(objFlameMixer, 1);
enemyDamageValue(objRainFlush, 1);
enemyDamageValue(objSparkShock, 0);
enemyDamageValue(objSearchSnake, 2);
enemyDamageValue(objTenguBlade, 1);
enemyDamageValue(objTenguDash, 1);
enemyDamageValue(objTenguDisk, 1);
enemyDamageValue(objSaltWater, 4);
enemyDamageValue(objConcreteShot, 1);
enemyDamageValue(objHomingSniper, 1);

// MaG24HMML
enemyDamageValue(objWaterWave, 1);
enemyDamageValue(objSuperArmBlockProjectile, 1);
enemyDamageValue(objSuperArmDebris, 1);
enemyDamageValue(objChillSpike, 1);
enemyDamageValue(objChillSpikeLanded, 1);

// Misc.
enemyDamageValue(objPowerStone, 1);
enemyDamageValue(objPlantBarrier, 0);
enemyDamageValue(objBlockDropper, 1);
enemyDamageValue(objIceSlasher, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (!global.frozen)
{
    // Knight Man's custom intro
    if (startIntro)
    {
        y -= view_hview;
        canFillHealthBar = false;
        startIntro = false;
        isIntro = true;
        visible = true;
        calibrateDirection();
        grav = gravAccel;
    }
    else if (isIntro)
    {
        // custom intro:
        if (!hasTriggeredFall)
        {
            imgIndex = 9;
        }
        if (y &gt;= ystart || hasTriggeredFall)
        {
            hasTriggeredFall = true;
            y = ystart;
            if (attackTimer == 0)
                imgIndex = 0;
            
            attackTimer++;
            
            // Intro animation
            if (attackTimer == 16)
            {
                imgIndex = 7;
            }
            if (attackTimer == 24)
            {
                imgIndex = 4;
            }
            if (attackTimer == 28)
            {
                imgIndex = 1;
            }
            if (attackTimer == 36)
            {
                imgIndex = 2;
            }
            if (attackTimer == 40)
            {
                imgIndex = 1;
            }
            if (attackTimer == 60)
            {
                canFillHealthBar = true;
                isIntro = false;
                attackTimer = 30; // Knight Man always attacks instantly at the start
                grav = myGravity;
                blockCollision = blockCollisionStart;
            }
        }
    }
}

// Actual fight data
if (entityCanStep())
{
    if (isFight)
    {
        switch (phase)
        {
            case 0: //Waiting
                calibrateDirection();
                
                attackTimer++;
                if (attackTimer &gt;= 30)
                {
                    attackTimer = 0;
                    phase = choose(1, 1, 1, 1, 2, 3, 3, 3);
                    if (phase == 1) // Choose jump height
                        jumpType = choose(0, 1);
                    if (phase == 3)
                    {
                        attackTimer = -4;
                        imgIndex = 0;
                    }
                }
                break;
           
            case 1: //Jump
                if (attackTimer == 0)
                {
                    calibrateDirection();
                    imgIndex = 9;
                    if (jumpType == 0) // High jump
                        yspeed = -6.5;
                    else // Not-Quite-As-High jump
                        yspeed = -5.8;
                    
                    if (instance_exists(target))
                    {
                        if ((abs(target.x - x)) &lt; targetJumpRange)
                        {
                            var targetJump = choose(0,1);
                            if (targetJump)
                            {
                                var undershot = 16 * -sign(image_xscale);
                                var i = choose(0,1);
                                startXspeed = arcCalcXspeed(yspeed, grav, x, y, bboxGetXCenterObject(target) + (undershot * i), bboxGetYCenterObject(target));
                            }
                            else
                            {
                                var i = choose(4,5,6);
                                startXspeed = arcCalcXspeed(yspeed, grav, x, y, x + (16 * i) * image_xscale, y);
                            }
                        }
                        else
                        {
                            var i = choose(4,5,6);
                            startXspeed = arcCalcXspeed(yspeed, grav, x, y, x + (16 * i) * image_xscale, y);
                        }
                    }
                    else
                        startXspeed = image_xscale * 1.5;
                }
                
                attackTimer++;
                
                if (xcoll == startXspeed * image_xscale) &amp;&amp; (startXspeed != 0) // Turn around when hitting a wall
                {
                    startXspeed *= -1;
                    image_xscale *= -1;
                }
               
                xspeed = startXspeed;
                
                if (ground) &amp;&amp; (attackTimer &gt;= 6)
                {
                    attackTimer = 0;
                    xspeed = 0;
                    phase = 0;
                    imgIndex = 0;
                    playSFX(sfxClamp);
                }
                break;
           
            case 2: //Walk
                if (attackTimer == 0)
                {
                    calibrateDirection();
                    if (instance_exists(target))
                    {
                        if ((abs(target.x - x)) &lt; targetJumpRange)
                            walkX = bboxGetXCenterObject(target) + (16 * -image_xscale);
                        else
                            walkX = x + (16 * 3) * image_xscale;
                    }
                    else
                        walkX = x + image_xscale * 16;
                }
                
                // Animation
                var animTable = makeArray(6,7,8,7);
                imgIndex = animTable[walkFrame];
                
                if (attackTimer mod 4 == 0)
                {
                    walkFrame++;
                    if (walkFrame &gt; 3)
                        walkFrame = 0;
                }
                attackTimer++; // Increment timer for animation
               
                xspeed = image_xscale * 1.75;
               
                if (image_xscale == 1 &amp;&amp; bboxGetXCenter() &gt;= walkX) || (image_xscale == -1 &amp;&amp; bboxGetXCenter() &lt;= walkX)
                || checkSolid(xspeed, 0, 0, 1)
                {
                    xspeed = 0;
                    attackTimer = 0;
                    phase = 0;
                    imgIndex = 0;
                }
                break;
           
            case 3: //Shoot
                switch (attackTimer) // Launch animation
                {
                    case 0:
                        imgIndex = 1;
                        break;
                    case 4:
                        imgIndex = 2;
                        break;
                    case 12:
                        imgIndex = 1;
                        break;
                    case 16:
                        imgIndex = 3;
                        break;
                    case 18: // Actually create Knight Crusher
                        imgIndex = 4;
                        with (instance_create(x + 14 * image_xscale, y + 7 * image_yscale, objKnightProjectile))
                        {
                            dir = other.image_xscale;
                            sprite_index = other.maceSprite;
                            contactDamage = other.maceDamage;
                            if (instance_exists(target)) &amp;&amp; ((target.x &gt; x &amp;&amp; dir == 1) || (target.x &lt; x &amp;&amp; dir == -1))
                                destX = bboxGetXCenterObject(target);
                            else
                                destX = x + dir * 16;
                            
                            var useAngle;
                            if (instance_exists(target))
                            {
                                useAngle = point_direction(x, y, bboxGetXCenterObject(target), bboxGetYCenterObject(target));
                                if ((useAngle &gt; 75 || useAngle &lt; 18) &amp;&amp; dir == 1)
                                    || ((useAngle &lt; 180-75 || useAngle &gt; 180-18) &amp;&amp; dir == -1)
                                {
                                    if (dir == 1)
                                        useAngle = 0;
                                    else
                                        useAngle = 180;
                                }
                            }
                            else
                            {
                                if (dir == 1)
                                    useAngle = 0;
                                else
                                    useAngle = 180;
                            }
                            angle = useAngle;
                        }
                        break;
                    case 22:
                        imgIndex = 5;
                        break;
                }
                attackTimer++;
                
                //Retrieving the shot
                if ((place_meeting(x, y, objKnightProjectile) || !instance_exists(objKnightProjectile) || attackTimer &gt;= 300)
                &amp;&amp; imgIndex &gt;= 5)
                {
                    var proceed = true;
                    var knightProjectile = instance_place(x, y, objKnightProjectile);
                    if (knightProjectile &gt;= 0)
                    {
                        if (knightProjectile.phase == 0)
                            proceed = false;
                    }
                   
                    if (proceed)
                    {
                        with (objKnightProjectile)
                            instance_destroy();
                        if (imgIndex &gt;= 5)
                        {
                            attackTimer = 0;
                            phase = 4;
                            imgIndex = 4;
                        }
                    }
                }
            break;
            
            case 4: //Retrieving shot
                switch (attackTimer)
                {
                    case 4:
                        imgIndex = 1;
                        break;
                    case 8:
                        imgIndex = 2;
                        break;
                    case 16:
                        imgIndex = 1;
                        break;
                }
                attackTimer++;
                if (attackTimer &gt;= 20)
                {
                    imgIndex = 0;
                    attackTimer = 0;
                    phase = 0;
                }
                break;
        }
    }
}
image_index = imgIndex div 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!hasShield)
    exit;

if (phase &lt; 4) &amp;&amp; ((imgIndex &lt; 3) || (imgIndex &gt;= 6))
{
    if (collision_rectangle(x + shieldX1 * image_xscale, y + shieldY1 * image_yscale,
        x + shieldX2 * image_xscale, y + shieldY2 * image_yscale, other.id, false, false))
    {
        other.guardCancel = 1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
with (objKnightProjectile)
{
    instance_create(bboxGetXCenter(),bboxGetYCenter(),objExplosion);
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (debugGuard)
{
    var col = draw_get_color();
    var alp = draw_get_alpha();
    draw_set_color(c_green);
    draw_set_alpha(0.5);
    draw_rectangle(x + shieldX1 * image_xscale, y + shieldY1 * image_yscale, x + shieldX2 * image_xscale, y + shieldY2 * image_yscale,true);
    draw_set_color(col);
    draw_set_alpha(alp);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
