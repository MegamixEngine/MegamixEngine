<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprObjectSetter</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>999999</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Autotiler for tilesets, place the whole tileset image somewhere in the level and place this
// object on the top left tile of the tileset, then place one of the supported objects of your choice over the tiles.
// If the object is flipped vertically the object setter will use the tile asociated to it as a chunk of tiles with the whole tileset
//preventing any weird behavior caused by using the object setter on an incomplete chunk of tiles

// only one autotiler runs this code:
if (id == object_index.id)
{
    /*
    var doTileSplit = false;
    if(image_xscale == -1)
    {
        image_xscale = 1;
        x -= 16;
        doTileSplit = true;
    }*/
    
    var doPrint = false;
    var file = -1;
    var printerInstance = 0;
    var doCombine = true;
    
    var printerObjectList = -1;
    
    if (DEBUG_ENABLED &amp;&amp; global.keyLeft[0] &amp;&amp; global.keyUp[0] &amp;&amp; global.keyMap[0])
    {
        doPrint = true;
        file = file_text_open_write("AutoTilerDump/" + room_get_name(room) + "-autoTilerDump.txt")
        printerObjectList = mm_ds_list_create();
    }
    
    var beginTime = get_timer();
    print("Autotile begin (instance " + string(id) + ")", WL_VERBOSE);
    
    // learn list of layers
    print("Determining layer set...", WL_VERBOSE);
    var preplace_time = get_timer();
    global.tileLayersN = 0;
    var tid_all = tile_get_ids();
    var tid_all_n = array_length_1d(tid_all);
    if (tid_all_n &lt;= 0)
        exit;
    var layers;
    layers[0] = 0;
    global.tileLayers = layers;
    for (var i = 0; i &lt; tid_all_n; i++)
    {
        var d = tile_get_depth(tid_all[i]);
        if (indexOf(global.tileLayers, d) == -1)
        {
            global.tileLayers[global.tileLayersN++] = d;
        }
    }
    
    print("Sorting layer set", WL_VERBOSE);
    
    // sort layer list
    quickSort(global.tileLayers, 0, global.tileLayersN);
    
    print("Layers found: " + string(global.tileLayers), WL_VERBOSE);
    
    // map from (layer, bg) -&gt; (automapper id)
    for (var i = 0; i &lt; global.tileLayersN; i++)
        global.automapper[i] = mm_ds_map_create(false);
    
    // set of instances which were placed during the autotiler process
    // maps (instance id) -&gt; (true)
    var placed_instances = mm_ds_map_create();
    
    // each object scans for a key and parses it
    with (object_index)
    {
        event_user(0);
    }
    
    preplace_time = get_timer() - preplace_time;
    print("Iterating through all tiles in all layers...", WL_VERBOSE);
    var place_time = get_timer();
    
    for (var layerIndex = 0; layerIndex &lt; global.tileLayersN; layerIndex++)
    {
        // list each tile on each layer
        var layer = global.tileLayers[layerIndex];
        
        /*
        if(doTileSplit)
        {
            var tid = tile_get_ids_at_depth(layer);
            var tid_n = array_length_1d(tid);
            for (var i = 0; i &lt; tid_n; i++)
            {
                splitTile(tid[i], grid, grid);
            }
        }*/
        
        print("Layer " + string(layer) + "...", WL_VERBOSE);

        print("  Placing instances...", WL_VERBOSE);
        
        // look at every tile in room and place objects
        var tid = tile_get_ids_at_depth(layer);
        var tid_n = array_length_1d(tid);
        var instance_placed_n = 0; // this variable is purely to help debugging
        var instance_place_time = get_timer();
        
        for (var i = 0; i &lt; tid_n; i++)
        {
            var tile = tid[i];
            // determine which objObjectSetter has the associated tileset
            var bg = tile_get_background(tile);
            
            var automapperID = ds_map_find_value(global.automapper[layerIndex], bg);
            
            if (is_undefined(automapperID))
            {
                continue;
            }
            
            var tWidth = tile_get_width(tile);
            var tHeight = tile_get_height(tile);
            if(!( (tWidth % grid == 0 ) &amp;&amp; (tHeight % grid == 0) ))
            {
                print("objTileSetter: skiping tile with size that can't be divided by the grid size ", WL_VERBOSE);
                continue;
            }
            
            var hTiles = floor(tWidth/grid);
            var vTiles = floor(tHeight/grid);
            var tileLeftStart = tile_get_left(tile);
            var tileTopStart = tile_get_top(tile);
            var tileXStart = tile_get_x(tile)
            var tileYStart = tile_get_y(tile)
            var tileX, tileY, tileLeft, tileTop;
            
            for(var vTile = 0; vTile &lt; vTiles; ++vTile)
            {
                for(var hTile = 0; hTile &lt; hTiles; ++hTile)
                {
                    tileY = tileYStart + grid*vTile;
                    tileX = tileXStart + grid*hTile;
                    tileLeft = tileLeftStart + grid*hTile;
                    tileTop = tileTopStart + grid*vTile;
                    
                    with (automapperID)
                    {
                        // figure out which object to place according to tileset key (which is determined in user defined 0)
                        var key_lookup_x = floor(tileLeft/grid) - key_left;
                        var key_lookup_y = floor(tileTop/grid) - key_top;
                        if( !((key_lookup_x&lt;0) || (key_lookup_x &gt; coordW-1) || (key_lookup_y&lt;0) || (key_lookup_y&gt;coordH-1)) )
                        {
                            var obj_id = coord[# key_lookup_x, key_lookup_y];
                            if (obj_id &gt;= 0)
                            {
                                with (instance_create(floor(tileX / grid) * grid, floor(tileY / grid) * grid, obj_id))
                                {
                                    placed_instances[? id] = true;
                                    isTile = true;
                                    visible = false;
                                    
                                    if(object_index == prtBossDoor || object_is_ancestor(object_index, prtBossDoor))
                                    {
                                        id.layer = layer;
                                    }
                                    
                                    if (doPrint)
                                    {
                                        if (!doCombine)
                                        {
                                            file_text_write_string(file,'    &lt;instance objName="' + object_get_name(object_index) + '" x="' + string(x) + 
                                            '" y="' + string(y) + 
                                            '" name="AT_' + string(printerInstance++) + 
                                            '" locked="0" code="isTile = true; visible = false;" scaleX="' + string(image_xscale) + 
                                            '" scaleY="' + string(image_yscale) + 
                                            '" colour="4294967295' +// string(image_blend) + 
                                            '" rotation="0' +// string(image_angle) 
                                            + '"/&gt;');
                                            file_text_writeln(file);
                                        }
                                        else
                                        {
                                            ds_list_add(printerObjectList,id);
                                        }
                                    }
                                    
                                    instance_placed_n++;
                                    
                                }   
                            }
                        }
                    }
                }
            }
            
        }
        
        print("  Placed " + string(instance_placed_n) + " instances.", WL_VERBOSE);
        print("  (" + string((get_timer() - instance_place_time) / 1000) + " ms)");
    }
    place_time = get_timer() - place_time;
    
    // clean up resources
    print("Cleaning up data structures...", WL_VERBOSE);
    var free_time = get_timer();
    print("  Freeing legend grids...", WL_VERBOSE);
    with (object_index)
    {
        mm_ds_grid_destroy(coord);
    }
    
    print("  Destroying secondary autotilers...", WL_VERBOSE);
    with (object_index)
    {
        if (id != other.id)
        {
            instance_destroy();
        }
    }
    
    print("  Freeing layer -&gt; autotiler map", WL_VERBOSE);
    for (var i = 0; i &lt; global.tileLayersN; i++)
        mm_ds_map_destroy(global.automapper[i]);
    
    print("  Freeing placed instances map", WL_VERBOSE);
    mm_ds_map_destroy(placed_instances);
    
    print("Finished object setting. Overall time taken: " + string((get_timer() - beginTime) / 1000) + " ms.", WL_VERBOSE);
    instance_destroy();
    
    free_time = get_timer() - free_time;
    print("  Pre-processing: " + string(preplace_time / 1000) + " ms");
    print("  tile placing: " + string(place_time / 1000) + " ms");
    print("  Freeing resources: " + string(free_time / 1000) + " ms");
    if (doPrint)
    {
        
        
        if (doCombine)
        {
            
            for (var i = 0; i &lt; obj_n; i++)
            {
                var hori = true;
                var vert = true;
                switch (obj[i])
                {
                    case objLadder:
                        hori = false;
                    break;
                    case objTopSolid:
                        vert = false;
                    break;
                    case objBossBarrier:
                    case objBossDoor:
                    case objBossDoorVertical:
                    case objLineHorizontalDrop:
                    case objSlopeR:
                    case objSlopeL:
                    case objSlopeRLong:
                    case objSlopeLLong:
                    case objLiftRail:
                    case objLiftHole:
                    case objLiftEnd:
                    case objLineVertical:
                    case objLineHorizontal:
                    case objLineTopLeft:
                    case objLineTopRight:
                    case objLineBottomLeft:
                    case objLineBottomRight:
                    case objLineVerticalDrop:
                    case objCossackSnow:
                        hori = false;
                        vert = false;
                    break;
                    
                    //CHECK WHICH CAN BE FIRST!!!
                    
                }
                if (hori || vert)
                {
                    combineObjectsFromList(obj[i],hori,vert,printerObjectList);//combineObjects
                }
            }
        }
        
        
        
        while (ds_list_size(printerObjectList) &gt; 0)
        {
            
            with (ds_list_find_value(printerObjectList,0))
            {
                file_text_write_string(file,'    &lt;instance objName="' + object_get_name(object_index) + '" x="' + string(x) + 
                                '" y="' + string(y) + 
                                '" name="AT_' + string(printerInstance++) + 
                                '" locked="0" code="isTile = true; visible = false;" scaleX="' + string(image_xscale) + 
                                '" scaleY="' + string(image_yscale) + 
                                '" colour="4294967295' +// string(image_blend) + 
                                '" rotation="0' +// string(image_angle) 
                                + '"/&gt;');
                                file_text_writeln(file);
                
            }
            ds_list_delete(printerObjectList,0);
        }
        
        
        
        
        
        
        
        file_text_close(file);
        mm_ds_list_destroy(printerObjectList);
        print("Dumped level auto-tile to appdata.",WL_SHOW);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var useTileAsTileset = (image_yscale&lt;0);

if(useTileAsTileset)
{
    image_yscale=1;
    y-=16;
}

/// parse key
var key = -1;

print("Parsing legend (instance " + string(id) + ")", WL_VERBOSE);
print("  Searching for legend...", WL_VERBOSE);

// search for key until one is found
for (var i = global.tileLayersN - 1; i &gt;= 0; i--)
{
    layer = global.tileLayers[i];
    layerIndex = i;
    key = tile_layer_find(layer, x + 8, y + 8);
    if (key != -1)
    {
        break;
    }
}

ERR_HEAD = "Autotile Error: ";

if (key == -1)
{
    printErr(ERR_HEAD + "Cannot find background key on any layer (at x = " + string(x) + ", y = " + string(y) + ")");
    exit;
}

// found a key and layer

grid = 16;


key_bg = tile_get_background(key);

if(!useTileAsTileset)
{
    key_width = tile_get_width(key);
    key_height = tile_get_height(key);
    key_left = floor(tile_get_left(key) / grid);
    key_top = floor(tile_get_top(key) / grid);
    key_x = tile_get_x(key) + grid*0.5;
    key_y = tile_get_y(key) + grid*0.5;
}
else
{
    key_left = tile_get_left(key);
    key_top = tile_get_top(key);
    
    key_width = abs(background_get_width(key_bg)-key_left);
    key_height = abs(background_get_height(key_bg)-key_top);
    key_left = floor(key_left / grid);
    key_top = floor(key_top / grid);
    key_x = tile_get_x(key) + grid*0.5;
    key_y = tile_get_y(key) + grid*0.5;
}

tile_delete(key);

print("  Legend found! " + background_get_name(key_bg) + " on layer " + string(layer), WL_VERBOSE);
print("  Scanning legend...", WL_VERBOSE);

ds_map_replace(global.automapper[layerIndex], key_bg, id);

coordW = ceil(key_width/grid);
coordH = ceil(key_height/grid);
coord = mm_ds_grid_create(coordW, coordH);

for (var i = 0; i &lt; coordW; i++)
{
    for (var j = 0; j &lt; coordH; j++)
    {
        coord[# i, j] = -1;
    }
}

// objects that can be autotiled
// make sure descendants are lower down in this list than their ancestors
obj[0] = objSolid;
obj[1] = objIce;
obj[2] = objTopSolid;
obj[3] = objLadder;
obj[4] = objSpike;
obj[5] = objWater;
obj[6] = objBossBarrier;
obj[7] = objBossDoor;
obj[8] = objBossDoorVertical;
obj[9] = objLineHorizontalDrop;
obj[10] = objStandSolid;
obj[11] = objSlopeR;
obj[12] = objSlopeL;
obj[13] = objSlopeRLong;
obj[14] = objSlopeLLong;
obj[15] = objDamageSpike;
obj[16] = objLiftRail;
obj[17] = objLiftHole;
obj[18] = objLiftEnd;
obj[19] = objLineVertical;
obj[20] = objLineHorizontal;
obj[21] = objLineTopLeft;
obj[22] = objLineTopRight;
obj[23] = objLineBottomLeft;
obj[24] = objLineBottomRight;
obj[25] = objLineVerticalDrop;
obj[26] = objCossackSnow;
obj[27] = objRailTopLeft;
obj[28] = objRailTopRight;
obj[29] = objRailBottomLeft;
obj[30] = objRailBottomRight;
obj[31] = objRailHorizontal;
obj[32] = objRailHorizontalHole;
obj[33] = objRailVertical;
obj[34] = objRailVerticalHole;
obj[35] = objRailBumper;
obj_n = array_length_1d(obj);

// scan key for objects
for (var _x = 0;_x &lt; coordW; ++_x) //_x &lt; key_width; _x += grid)
{
    for (var _y = 0; _y &lt; coordH; ++_y)// &lt; key_height; _y += grid)
    {
        var obj_found = noone;
        
        for (var i = 0; i &lt; obj_n; i++) // find object located at this point
        {
            if (position_meeting(key_x + _x*grid, key_y + _y*grid, obj[i]))
            {
                obj_found=obj[i];
            }
        }
        
        if (obj_found) // object found - add to list
        {
            coord[# _x, _y] = obj_found;
        }
    }
}

print("  Scan complete.", WL_VERBOSE);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
